üîù Retour au [Sommaire](/SOMMAIRE.md)

# 12.10 Design patterns basics (Singleton, Factory)

## Introduction : Qu'est-ce qu'un design pattern ?

### D√©finition simple

Un **design pattern** (patron de conception) est une **solution r√©utilisable** √† un probl√®me courant en programmation. C'est comme une recette de cuisine : une m√©thode √©prouv√©e pour r√©soudre un type de probl√®me sp√©cifique.

**Analogie : Les plans d'architecte**
- Un architecte ne r√©invente pas la roue pour chaque maison
- Il utilise des plans standards : cuisine, chambre, salle de bain
- Chaque plan r√©sout un probl√®me sp√©cifique (o√π manger, o√π dormir)
- Les design patterns sont les "plans standards" de la programmation

### Pourquoi utiliser des design patterns ?

‚úÖ **Solutions √©prouv√©es** : Test√©es par des milliers de d√©veloppeurs
‚úÖ **Vocabulaire commun** : Facilite la communication entre d√©veloppeurs
‚úÖ **Code maintenable** : Structure claire et logique
‚úÖ **√âvite les erreurs** : Pr√©vient les probl√®mes connus
‚úÖ **Gagne du temps** : Pas besoin de r√©inventer la solution

### Les patterns que vous allez apprendre

Dans cette section, nous couvrons deux patterns essentiels :

1. **Singleton** : Garantir qu'il n'existe qu'une seule instance d'une classe
2. **Factory** : Cr√©er des objets sans exposer la logique de cr√©ation

---

## Pattern 1 : Singleton

### Le probl√®me

Certaines classes ne doivent avoir qu'**une seule instance** dans toute l'application :
- Configuration de l'application
- Gestionnaire de base de donn√©es
- Logger (syst√®me de journalisation)
- Gestionnaire de cache

**Exemple du probl√®me :**

```pascal
// ‚ùå Sans Singleton : plusieurs instances peuvent √™tre cr√©√©es
var
  Config1, Config2: TConfiguration;
begin
  Config1 := TConfiguration.Create;
  Config2 := TConfiguration.Create;

  Config1.Langue := 'Fran√ßais';
  Config2.Langue := 'Anglais';

  // ‚ö†Ô∏è PROBL√àME : Deux configurations diff√©rentes !
  // Laquelle est la "vraie" configuration ?
end;
```

### La solution : Le pattern Singleton

Le Singleton garantit :
- ‚úÖ Une seule instance existe
- ‚úÖ Point d'acc√®s global √† cette instance
- ‚úÖ Instance cr√©√©e seulement quand n√©cessaire (lazy initialization)

### Impl√©mentation du Singleton

```pascal
type
  TConfiguration = class
  private
    // Instance unique (attribut de classe)
    class var FInstance: TConfiguration;

    // Attributs de configuration
    FLangue: string;
    FTheme: string;
    FDossierDonnees: string;

    // Constructeur priv√© : emp√™che la cr√©ation directe
    constructor CreatePrivate;
  public
    // Point d'acc√®s unique √† l'instance
    class function Instance: TConfiguration;
    class procedure LibererInstance;

    // Properties de configuration
    property Langue: string read FLangue write FLangue;
    property Theme: string read FTheme write FTheme;
    property DossierDonnees: string read FDossierDonnees write FDossierDonnees;
  end;

// Initialisation de l'attribut de classe
class var TConfiguration.FInstance: TConfiguration = nil;

// Constructeur priv√©
constructor TConfiguration.CreatePrivate;
begin
  inherited Create;
  // Valeurs par d√©faut
  FLangue := 'Fran√ßais';
  FTheme := 'Clair';
  FDossierDonnees := './data';
  WriteLn('‚öôÔ∏è  Configuration initialis√©e');
end;

// M√©thode pour obtenir l''instance unique
class function TConfiguration.Instance: TConfiguration;
begin
  // Si l'instance n'existe pas, la cr√©er
  if FInstance = nil then
  begin
    WriteLn('üîß Cr√©ation de l''instance Singleton');
    FInstance := TConfiguration.CreatePrivate;
  end
  else
    WriteLn('‚ôªÔ∏è  R√©utilisation de l''instance existante');

  Result := FInstance;
end;

// M√©thode pour lib√©rer l'instance
class procedure TConfiguration.LibererInstance;
begin
  if FInstance <> nil then
  begin
    WriteLn('üóëÔ∏è  Lib√©ration du Singleton');
    FInstance.Free;
    FInstance := nil;
  end;
end;
```

### Utilisation du Singleton

```pascal
var
  Config1, Config2, Config3: TConfiguration;
begin
  WriteLn('=== Test du Singleton ===');
  WriteLn('');

  // Premier acc√®s : cr√©e l'instance
  WriteLn('‚ñ∂ Premier acc√®s');
  Config1 := TConfiguration.Instance;
  Config1.Langue := 'Fran√ßais';
  Config1.Theme := 'Sombre';
  WriteLn('Config1 - Langue : ', Config1.Langue, ', Th√®me : ', Config1.Theme);
  WriteLn('');

  // Deuxi√®me acc√®s : r√©utilise la m√™me instance
  WriteLn('‚ñ∂ Deuxi√®me acc√®s');
  Config2 := TConfiguration.Instance;
  WriteLn('Config2 - Langue : ', Config2.Langue, ', Th√®me : ', Config2.Theme);
  WriteLn('');

  // Troisi√®me acc√®s : toujours la m√™me instance
  WriteLn('‚ñ∂ Troisi√®me acc√®s');
  Config3 := TConfiguration.Instance;
  Config3.Langue := 'Anglais';  // Modifie l'instance unique
  WriteLn('Config3 - Langue : ', Config3.Langue);
  WriteLn('');

  // V√©rification : tous pointent vers le m√™me objet
  WriteLn('‚ñ∂ V√©rification');
  WriteLn('Config1 = Config2 ? ', Config1 = Config2);
  WriteLn('Config2 = Config3 ? ', Config2 = Config3);
  WriteLn('Config1.Langue (apr√®s modification par Config3) : ', Config1.Langue);
  WriteLn('');

  // Lib√©ration (une seule fois pour tout le monde)
  TConfiguration.LibererInstance;
end.
```

**R√©sultat :**
```
=== Test du Singleton ===

‚ñ∂ Premier acc√®s
üîß Cr√©ation de l'instance Singleton
‚öôÔ∏è  Configuration initialis√©e
Config1 - Langue : Fran√ßais, Th√®me : Sombre

‚ñ∂ Deuxi√®me acc√®s
‚ôªÔ∏è  R√©utilisation de l'instance existante
Config2 - Langue : Fran√ßais, Th√®me : Sombre

‚ñ∂ Troisi√®me acc√®s
‚ôªÔ∏è  R√©utilisation de l'instance existante
Config3 - Langue : Anglais

‚ñ∂ V√©rification
Config1 = Config2 ? TRUE
Config2 = Config3 ? TRUE
Config1.Langue (apr√®s modification par Config3) : Anglais

üóëÔ∏è  Lib√©ration du Singleton
```

### Quand utiliser le Singleton ?

#### ‚úÖ Utilisez le Singleton pour :

1. **Configuration globale** : Param√®tres de l'application
2. **Logger** : Syst√®me de journalisation unique
3. **Gestionnaire de connexion** : Pool de connexions BD
4. **Cache** : M√©moire cache partag√©e
5. **Gestionnaire de ressources** : Fichiers, images, sons

#### ‚ùå N'utilisez PAS le Singleton pour :

1. Classes qui peuvent avoir plusieurs instances l√©gitimement
2. Donn√©es qui doivent √™tre isol√©es (tests unitaires)
3. Tout ce qui pourrait √©voluer vers plusieurs instances

### Exemple pratique : Logger Singleton

```pascal
type
  TNiveauLog = (nlDebug, nlInfo, nlWarning, nlError);

  TLogger = class
  private
    class var FInstance: TLogger;
    FFichier: TextFile;
    FFichierOuvert: Boolean;

    constructor CreatePrivate;
  public
    destructor Destroy; override;

    class function Instance: TLogger;
    class procedure LibererInstance;

    procedure Log(Niveau: TNiveauLog; const Message: string);
    procedure Debug(const Message: string);
    procedure Info(const Message: string);
    procedure Warning(const Message: string);
    procedure Error(const Message: string);
  end;

class var TLogger.FInstance: TLogger = nil;

constructor TLogger.CreatePrivate;
begin
  inherited Create;
  AssignFile(FFichier, 'application.log');
  try
    Rewrite(FFichier);
    FFichierOuvert := True;
    WriteLn('üìù Logger initialis√©');
  except
    FFichierOuvert := False;
    WriteLn('‚ö†Ô∏è  Impossible d''ouvrir le fichier de log');
  end;
end;

destructor TLogger.Destroy;
begin
  if FFichierOuvert then
  begin
    CloseFile(FFichier);
    WriteLn('üìù Logger ferm√©');
  end;
  inherited;
end;

class function TLogger.Instance: TLogger;
begin
  if FInstance = nil then
    FInstance := TLogger.CreatePrivate;
  Result := FInstance;
end;

class procedure TLogger.LibererInstance;
begin
  if FInstance <> nil then
  begin
    FInstance.Free;
    FInstance := nil;
  end;
end;

procedure TLogger.Log(Niveau: TNiveauLog; const Message: string);
const
  NiveauTexte: array[TNiveauLog] of string = ('DEBUG', 'INFO', 'WARNING', 'ERROR');
var
  Ligne: string;
begin
  Ligne := Format('[%s] [%s] %s', [DateTimeToStr(Now), NiveauTexte[Niveau], Message]);
  WriteLn(Ligne);

  if FFichierOuvert then
    WriteLn(FFichier, Ligne);
end;

procedure TLogger.Debug(const Message: string);
begin
  Log(nlDebug, Message);
end;

procedure TLogger.Info(const Message: string);
begin
  Log(nlInfo, Message);
end;

procedure TLogger.Warning(const Message: string);
begin
  Log(nlWarning, Message);
end;

procedure TLogger.Error(const Message: string);
begin
  Log(nlError, Message);
end;
```

**Utilisation du Logger :**

```pascal
begin
  // Partout dans l'application, on peut logger facilement
  TLogger.Instance.Info('Application d√©marr√©e');
  TLogger.Instance.Debug('Chargement de la configuration');
  TLogger.Instance.Warning('M√©moire cache limit√©e');
  TLogger.Instance.Error('Impossible de se connecter √† la base');

  // Lib√©ration √† la fin de l'application
  TLogger.LibererInstance;
end.
```

---

## Pattern 2 : Factory (Fabrique)

### Le probl√®me

Cr√©er des objets peut devenir complexe :
- Logique de cr√©ation compliqu√©e
- Besoin de choisir quelle classe instancier
- D√©pendance forte au constructeur

**Exemple du probl√®me :**

```pascal
// ‚ùå Sans Factory : logique de cr√©ation √©parpill√©e
var
  Transport: TTransport;
begin
  if TypeTransport = 'voiture' then
    Transport := TVoiture.Create(4, 'Essence')
  else if TypeTransport = 'moto' then
    Transport := TMoto.Create(2, 'Essence')
  else if TypeTransport = 'velo' then
    Transport := TVelo.Create(2, 'Humaine');

  // ‚ö†Ô∏è Code de cr√©ation r√©p√©t√© partout dans l'application
end;
```

### La solution : Le pattern Factory

Le Factory :
- ‚úÖ Centralise la logique de cr√©ation
- ‚úÖ D√©couple le code client de la classe concr√®te
- ‚úÖ Facilite l'ajout de nouveaux types
- ‚úÖ Code plus maintenable

### Impl√©mentation du Factory

```pascal
type
  // Interface commune pour tous les transports
  ITransport = interface
    ['{11111111-2222-3333-4444-555555555555}']
    procedure Demarrer;
    procedure Avancer;
    procedure Arreter;
    function ObtenirType: string;
  end;

  // Impl√©mentations concr√®tes
  TVoiture = class(TInterfacedObject, ITransport)
  public
    procedure Demarrer;
    procedure Avancer;
    procedure Arreter;
    function ObtenirType: string;
  end;

  TMoto = class(TInterfacedObject, ITransport)
  public
    procedure Demarrer;
    procedure Avancer;
    procedure Arreter;
    function ObtenirType: string;
  end;

  TVelo = class(TInterfacedObject, ITransport)
  public
    procedure Demarrer;
    procedure Avancer;
    procedure Arreter;
    function ObtenirType: string;
  end;

  // ‚úÖ FACTORY : Classe qui cr√©e les transports
  TTransportFactory = class
  public
    class function CreerTransport(const TypeTransport: string): ITransport;
  end;

// Impl√©mentations
procedure TVoiture.Demarrer;
begin
  WriteLn('üöó Voiture : D√©marrage du moteur');
end;

procedure TVoiture.Avancer;
begin
  WriteLn('üöó Voiture : Vroum ! La voiture roule');
end;

procedure TVoiture.Arreter;
begin
  WriteLn('üöó Voiture : Arr√™t en douceur');
end;

function TVoiture.ObtenirType: string;
begin
  Result := 'Voiture';
end;

procedure TMoto.Demarrer;
begin
  WriteLn('üèçÔ∏è  Moto : Kick ! Le moteur d√©marre');
end;

procedure TMoto.Avancer;
begin
  WriteLn('üèçÔ∏è  Moto : Vrouuum ! La moto file');
end;

procedure TMoto.Arreter;
begin
  WriteLn('üèçÔ∏è  Moto : Freinage');
end;

function TMoto.ObtenirType: string;
begin
  Result := 'Moto';
end;

procedure TVelo.Demarrer;
begin
  WriteLn('üö¥ V√©lo : On enfourche le v√©lo');
end;

procedure TVelo.Avancer;
begin
  WriteLn('üö¥ V√©lo : P√©dalage en cours');
end;

procedure TVelo.Arreter;
begin
  WriteLn('üö¥ V√©lo : On pose le pied');
end;

function TVelo.ObtenirType: string;
begin
  Result := 'V√©lo';
end;

// ‚úÖ Impl√©mentation de la Factory
class function TTransportFactory.CreerTransport(const TypeTransport: string): ITransport;
begin
  WriteLn('üè≠ Factory : Cr√©ation d''un transport de type "', TypeTransport, '"');

  // Logique de cr√©ation centralis√©e
  if TypeTransport = 'voiture' then
    Result := TVoiture.Create
  else if TypeTransport = 'moto' then
    Result := TMoto.Create
  else if TypeTransport = 'velo' then
    Result := TVelo.Create
  else
  begin
    WriteLn('‚ùå Type de transport inconnu : ', TypeTransport);
    raise Exception.Create('Type de transport non support√©');
  end;
end;
```

### Utilisation du Factory

```pascal
procedure UtiliserTransport(Transport: ITransport);
begin
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn('Utilisation du transport : ', Transport.ObtenirType);
  Transport.Demarrer;
  Transport.Avancer;
  Transport.Arreter;
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn('');
end;

var
  Transport: ITransport;
begin
  WriteLn('=== D√©monstration du Pattern Factory ===');
  WriteLn('');

  // ‚úÖ Utilisation simple : pas besoin de conna√Ætre les classes concr√®tes
  Transport := TTransportFactory.CreerTransport('voiture');
  UtiliserTransport(Transport);

  Transport := TTransportFactory.CreerTransport('moto');
  UtiliserTransport(Transport);

  Transport := TTransportFactory.CreerTransport('velo');
  UtiliserTransport(Transport);

  // Pas de Free n√©cessaire : gestion automatique via interface
end.
```

**R√©sultat :**
```
=== D√©monstration du Pattern Factory ===

üè≠ Factory : Cr√©ation d'un transport de type "voiture"
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Utilisation du transport : Voiture
üöó Voiture : D√©marrage du moteur
üöó Voiture : Vroum ! La voiture roule
üöó Voiture : Arr√™t en douceur
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üè≠ Factory : Cr√©ation d'un transport de type "moto"
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Utilisation du transport : Moto
üèçÔ∏è  Moto : Kick ! Le moteur d√©marre
üèçÔ∏è  Moto : Vrouuum ! La moto file
üèçÔ∏è  Moto : Freinage
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üè≠ Factory : Cr√©ation d'un transport de type "velo"
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Utilisation du transport : V√©lo
üö¥ V√©lo : On enfourche le v√©lo
üö¥ V√©lo : P√©dalage en cours
üö¥ V√©lo : On pose le pied
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
```

### Quand utiliser le Factory ?

#### ‚úÖ Utilisez le Factory pour :

1. **Cr√©ation conditionnelle** : Choisir quelle classe instancier selon un crit√®re
2. **Logique complexe** : La cr√©ation n√©cessite plusieurs √©tapes
3. **D√©couplage** : Le code client ne doit pas conna√Ætre les classes concr√®tes
4. **Plusieurs variantes** : De nombreuses classes impl√©mentent la m√™me interface
5. **Configuration** : Cr√©er des objets depuis des fichiers de config

#### ‚ùå N'utilisez PAS le Factory pour :

1. Cr√©ations simples sans logique
2. Une seule classe √† instancier
3. Quand la complexit√© ajout√©e n'apporte rien

---

## Factory avanc√© : Factory Method Pattern

### Diff√©rence avec Simple Factory

- **Simple Factory** : Une classe avec une m√©thode statique
- **Factory Method** : M√©thode virtuelle dans une hi√©rarchie de classes

### Impl√©mentation du Factory Method

```pascal
type
  // Interface du produit
  IDocument = interface
    ['{22222222-3333-4444-5555-666666666666}']
    procedure Ouvrir;
    procedure Afficher;
    procedure Fermer;
  end;

  // Produits concrets
  TDocumentTexte = class(TInterfacedObject, IDocument)
  public
    procedure Ouvrir;
    procedure Afficher;
    procedure Fermer;
  end;

  TDocumentPDF = class(TInterfacedObject, IDocument)
  public
    procedure Ouvrir;
    procedure Afficher;
    procedure Fermer;
  end;

  // ‚úÖ Cr√©ateur abstrait avec Factory Method
  TEditeur = class abstract
  public
    // Factory Method (virtuelle)
    function CreerDocument: IDocument; virtual; abstract;

    // M√©thode qui utilise le Factory Method
    procedure OuvrirEtAfficher;
  end;

  // Cr√©ateurs concrets
  TEditeurTexte = class(TEditeur)
  public
    function CreerDocument: IDocument; override;
  end;

  TEditeurPDF = class(TEditeur)
  public
    function CreerDocument: IDocument; override;
  end;

// Impl√©mentations des documents
procedure TDocumentTexte.Ouvrir;
begin
  WriteLn('üìÑ Ouverture d''un document texte');
end;

procedure TDocumentTexte.Afficher;
begin
  WriteLn('üìñ Affichage du contenu texte');
end;

procedure TDocumentTexte.Fermer;
begin
  WriteLn('üìÑ Fermeture du document texte');
end;

procedure TDocumentPDF.Ouvrir;
begin
  WriteLn('üìï Ouverture d''un document PDF');
end;

procedure TDocumentPDF.Afficher;
begin
  WriteLn('üìö Affichage du PDF avec mise en page');
end;

procedure TDocumentPDF.Fermer;
begin
  WriteLn('üìï Fermeture du document PDF');
end;

// Impl√©mentation du cr√©ateur abstrait
procedure TEditeur.OuvrirEtAfficher;
var
  Doc: IDocument;
begin
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  Doc := CreerDocument;  // ‚Üê Appel du Factory Method
  Doc.Ouvrir;
  Doc.Afficher;
  Doc.Fermer;
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn('');
end;

// Cr√©ateurs concrets
function TEditeurTexte.CreerDocument: IDocument;
begin
  WriteLn('üè≠ Cr√©ation d''un document texte');
  Result := TDocumentTexte.Create;
end;

function TEditeurPDF.CreerDocument: IDocument;
begin
  WriteLn('üè≠ Cr√©ation d''un document PDF');
  Result := TDocumentPDF.Create;
end;
```

**Utilisation :**

```pascal
var
  Editeur: TEditeur;
begin
  WriteLn('=== Factory Method Pattern ===');
  WriteLn('');

  // √âditeur texte
  Editeur := TEditeurTexte.Create;
  Editeur.OuvrirEtAfficher;
  Editeur.Free;

  // √âditeur PDF
  Editeur := TEditeurPDF.Create;
  Editeur.OuvrirEtAfficher;
  Editeur.Free;
end.
```

**R√©sultat :**
```
=== Factory Method Pattern ===

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üè≠ Cr√©ation d'un document texte
üìÑ Ouverture d'un document texte
üìñ Affichage du contenu texte
üìÑ Fermeture du document texte
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üè≠ Cr√©ation d'un document PDF
üìï Ouverture d'un document PDF
üìö Affichage du PDF avec mise en page
üìï Fermeture du document PDF
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
```

---

## Exemple complet : Application avec Singleton et Factory

### Syst√®me de gestion d'utilisateurs

```pascal
type
  // Niveaux d'utilisateur
  TNiveauUtilisateur = (nuInvite, nuUtilisateur, nuAdmin);

  // Interface utilisateur
  IUtilisateur = interface
    ['{33333333-4444-5555-6666-777777777777}']
    function ObtenirNom: string;
    function ObtenirNiveau: TNiveauUtilisateur;
    procedure SeConnecter;
    procedure SeDeconnecter;
  end;

  // Impl√©mentations concr√®tes
  TUtilisateurInvite = class(TInterfacedObject, IUtilisateur)
  private
    FNom: string;
  public
    constructor Create(const Nom: string);
    function ObtenirNom: string;
    function ObtenirNiveau: TNiveauUtilisateur;
    procedure SeConnecter;
    procedure SeDeconnecter;
  end;

  TUtilisateurStandard = class(TInterfacedObject, IUtilisateur)
  private
    FNom: string;
  public
    constructor Create(const Nom: string);
    function ObtenirNom: string;
    function ObtenirNiveau: TNiveauUtilisateur;
    procedure SeConnecter;
    procedure SeDeconnecter;
  end;

  TUtilisateurAdmin = class(TInterfacedObject, IUtilisateur)
  private
    FNom: string;
  public
    constructor Create(const Nom: string);
    function ObtenirNom: string;
    function ObtenirNiveau: TNiveauUtilisateur;
    procedure SeConnecter;
    procedure SeDeconnecter;
  end;

  // ‚úÖ SINGLETON : Gestionnaire de session
  TGestionnaireSession = class
  private
    class var FInstance: TGestionnaireSession;
    FUtilisateurCourant: IUtilisateur;

    constructor CreatePrivate;
  public
    class function Instance: TGestionnaireSession;
    class procedure LibererInstance;

    procedure ConnecterUtilisateur(Utilisateur: IUtilisateur);
    procedure DeconnecterUtilisateur;
    function ObtenirUtilisateurCourant: IUtilisateur;
    function EstConnecte: Boolean;
  end;

  // ‚úÖ FACTORY : Fabrique d'utilisateurs
  TUtilisateurFactory = class
  public
    class function CreerUtilisateur(Niveau: TNiveauUtilisateur; const Nom: string): IUtilisateur;
  end;

// Impl√©mentations des utilisateurs
constructor TUtilisateurInvite.Create(const Nom: string);
begin
  inherited Create;
  FNom := Nom;
end;

function TUtilisateurInvite.ObtenirNom: string;
begin
  Result := FNom;
end;

function TUtilisateurInvite.ObtenirNiveau: TNiveauUtilisateur;
begin
  Result := nuInvite;
end;

procedure TUtilisateurInvite.SeConnecter;
begin
  WriteLn('üë§ Invit√© "', FNom, '" connect√© (acc√®s limit√©)');
end;

procedure TUtilisateurInvite.SeDeconnecter;
begin
  WriteLn('üëã Invit√© "', FNom, '" d√©connect√©');
end;

constructor TUtilisateurStandard.Create(const Nom: string);
begin
  inherited Create;
  FNom := Nom;
end;

function TUtilisateurStandard.ObtenirNom: string;
begin
  Result := FNom;
end;

function TUtilisateurStandard.ObtenirNiveau: TNiveauUtilisateur;
begin
  Result := nuUtilisateur;
end;

procedure TUtilisateurStandard.SeConnecter;
begin
  WriteLn('üë§ Utilisateur "', FNom, '" connect√© (acc√®s standard)');
end;

procedure TUtilisateurStandard.SeDeconnecter;
begin
  WriteLn('üëã Utilisateur "', FNom, '" d√©connect√©');
end;

constructor TUtilisateurAdmin.Create(const Nom: string);
begin
  inherited Create;
  FNom := Nom;
end;

function TUtilisateurAdmin.ObtenirNom: string;
begin
  Result := FNom;
end;

function TUtilisateurAdmin.ObtenirNiveau: TNiveauUtilisateur;
begin
  Result := nuAdmin;
end;

procedure TUtilisateurAdmin.SeConnecter;
begin
  WriteLn('üëë Administrateur "', FNom, '" connect√© (acc√®s total)');
end;

procedure TUtilisateurAdmin.SeDeconnecter;
begin
  WriteLn('üëã Administrateur "', FNom, '" d√©connect√©');
end;

// Impl√©mentation du Singleton
class var TGestionnaireSession.FInstance: TGestionnaireSession = nil;

constructor TGestionnaireSession.CreatePrivate;
begin
  inherited Create;
  FUtilisateurCourant := nil;
  WriteLn('üîß Gestionnaire de session initialis√©');
end;

class function TGestionnaireSession.Instance: TGestionnaireSession;
begin
  if FInstance = nil then
    FInstance := TGestionnaireSession.CreatePrivate;
  Result := FInstance;
end;

class procedure TGestionnaireSession.LibererInstance;
begin
  if FInstance <> nil then
  begin
    FInstance.Free;
    FInstance := nil;
  end;
end;

procedure TGestionnaireSession.ConnecterUtilisateur(Utilisateur: IUtilisateur);
begin
  if FUtilisateurCourant <> nil then
    FUtilisateurCourant.SeDeconnecter;

  FUtilisateurCourant := Utilisateur;
  FUtilisateurCourant.SeConnecter;
end;

procedure TGestionnaireSession.DeconnecterUtilisateur;
begin
  if FUtilisateurCourant <> nil then
  begin
    FUtilisateurCourant.SeDeconnecter;
    FUtilisateurCourant := nil;
  end
  else
    WriteLn('‚ö†Ô∏è  Aucun utilisateur connect√©');
end;

function TGestionnaireSession.ObtenirUtilisateurCourant: IUtilisateur;
begin
  Result := FUtilisateurCourant;
end;

function TGestionnaireSession.EstConnecte: Boolean;
begin
  Result := FUtilisateurCourant <> nil;
end;

// Impl√©mentation du Factory
class function TUtilisateurFactory.CreerUtilisateur(Niveau: TNiveauUtilisateur; const Nom: string): IUtilisateur;
begin
  WriteLn('üè≠ Cr√©ation d''un utilisateur : ', Nom);

  case Niveau of
    nuInvite: Result := TUtilisateurInvite.Create(Nom);
    nuUtilisateur: Result := TUtilisateurStandard.Create(Nom);
    nuAdmin: Result := TUtilisateurAdmin.Create(Nom);
  else
    raise Exception.Create('Niveau d''utilisateur inconnu');
  end;
end;
```

**Utilisation compl√®te :**

```pascal
var
  Session: TGestionnaireSession;
  User: IUtilisateur;
begin
  WriteLn('=== Syst√®me de Gestion d''Utilisateurs ===');
  WriteLn('');

  // Singleton : une seule session pour toute l'application
  Session := TGestionnaireSession.Instance;
  WriteLn('');

  // Factory : cr√©ation d'utilisateurs
  WriteLn('‚ñ∂ Connexion invit√©');
  User := TUtilisateurFactory.CreerUtilisateur(nuInvite, 'Bob');
  Session.ConnecterUtilisateur(User);
  WriteLn('Connect√© ? ', Session.EstConnecte);
  WriteLn('');

  // Changement d'utilisateur
  WriteLn('‚ñ∂ Connexion utilisateur standard');
  User := TUtilisateurFactory.CreerUtilisateur(nuUtilisateur, 'Alice');
  Session.ConnecterUtilisateur(User);
  WriteLn('');

  // Affichage de l'utilisateur courant
  WriteLn('‚ñ∂ Utilisateur courant');
  if Session.EstConnecte then
  begin
    User := Session.ObtenirUtilisateurCourant;
    WriteLn('Nom : ', User.ObtenirNom);
  end;
  WriteLn('');

  // Connexion admin
  WriteLn('‚ñ∂ Connexion administrateur');
  User := TUtilisateurFactory.CreerUtilisateur(nuAdmin, 'SuperAdmin');
  Session.ConnecterUtilisateur(User);
  WriteLn('');

  // D√©connexion
  WriteLn('‚ñ∂ D√©connexion');
  Session.DeconnecterUtilisateur;
  WriteLn('Connect√© ? ', Session.EstConnecte);
  WriteLn('');

  // Lib√©ration du singleton
  TGestionnaireSession.LibererInstance;
end.
```

---

## Avantages et inconv√©nients

### Singleton

**Avantages :**
‚úÖ Instance unique garantie
‚úÖ Point d'acc√®s global
‚úÖ Initialisation paresseuse (lazy)
‚úÖ √âconomie de m√©moire

**Inconv√©nients :**
‚ö†Ô∏è √âtat global (difficile √† tester)
‚ö†Ô∏è Couplage fort
‚ö†Ô∏è Peut cacher des d√©pendances
‚ö†Ô∏è Probl√®mes en multi-threading (sans pr√©cautions)

### Factory

**Avantages :**
‚úÖ D√©couplage (code client vs classes concr√®tes)
‚úÖ Logique de cr√©ation centralis√©e
‚úÖ Facilite l'ajout de nouveaux types
‚úÖ Code plus maintenable

**Inconv√©nients :**
‚ö†Ô∏è Complexit√© ajout√©e
‚ö†Ô∏è Plus de classes √† g√©rer
‚ö†Ô∏è Peut √™tre "over-engineering" pour des cas simples

---

## R√©sum√©

### Pattern Singleton
**But :** Garantir qu'une classe n'a qu'une seule instance

**Structure :**
- Constructeur priv√©
- Attribut de classe statique
- M√©thode `Instance` pour obtenir l'instance unique

**Quand l'utiliser :**
- Configuration
- Logger
- Gestionnaire de ressources partag√©es

### Pattern Factory
**But :** Cr√©er des objets sans exposer la logique de cr√©ation

**Structure :**
- Interface commune pour les produits
- M√©thode de cr√©ation centralis√©e
- Retourne l'interface, pas la classe concr√®te

**Quand l'utiliser :**
- Cr√©ation conditionnelle
- Logique complexe
- D√©couplage n√©cessaire

### Points cl√©s

**Singleton :**
```pascal
class function Instance: TClasse;
begin
  if FInstance = nil then
    FInstance := TClasse.CreatePrivate;
  Result := FInstance;
end;
```

**Factory :**
```pascal
class function Creer(Type: string): IInterface;
begin
  case Type of
    'A': Result := TClasseA.Create;
    'B': Result := TClasseB.Create;
  end;
end;
```

### R√®gles d'or
- ‚úÖ Utilisez ces patterns quand ils simplifient vraiment le code
- ‚ùå N'en abusez pas : la simplicit√© prime
- ‚úÖ Documentez pourquoi vous utilisez un pattern
- ‚úÖ Testez votre code (les patterns doivent faciliter les tests)

---

## Conclusion du chapitre 12

F√©licitations ! Vous avez termin√© le chapitre sur les interfaces et la POO avanc√©e. Vous ma√Ætrisez maintenant :

‚úÖ **Interfaces** : Contrats et polymorphisme
‚úÖ **H√©ritage multiple** : Via les interfaces
‚úÖ **IInterface** : Comptage de r√©f√©rences automatique
‚úÖ **Properties** : Getters/setters √©l√©gants
‚úÖ **M√©thodes de classe** : Fonctionnalit√©s sans instance
‚úÖ **Design patterns** : Solutions √©prouv√©es (Singleton, Factory)

Ces concepts vous permettent de cr√©er des architectures logicielles **solides, maintenables et √©volutives**. Continuez √† pratiquer et √† explorer d'autres patterns pour devenir un d√©veloppeur Pascal accompli !

‚è≠Ô∏è [Gestion des Exceptions](/13-gestion-exceptions/README.md)
