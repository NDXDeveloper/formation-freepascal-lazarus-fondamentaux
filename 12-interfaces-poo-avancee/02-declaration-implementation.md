üîù Retour au [Sommaire](/SOMMAIRE.md)

# 12.2 D√©claration et impl√©mentation

## Introduction

Maintenant que vous comprenez le concept d'interface, il est temps d'apprendre √† les d√©clarer et √† les impl√©menter correctement. Cette section vous guidera pas √† pas √† travers la syntaxe exacte et les r√®gles √† respecter.

---

## D√©claration d'une interface

### Structure de base

Une interface se d√©clare dans la section `type` de votre unit√©, comme une classe :

```pascal
type
  INomInterface = interface
    ['{GUID}']
    // D√©clarations des m√©thodes
  end;
```

**√âl√©ments constitutifs :**
1. Le mot-cl√© `interface`
2. Un GUID (identifiant unique) optionnel mais recommand√©
3. Les d√©clarations de m√©thodes (pas d'impl√©mentation)
4. Le mot-cl√© `end`

### Convention de nommage

Par convention, les interfaces commencent toujours par la lettre **I** majuscule :

‚úÖ **Bon :**
- `IConnectable`
- `ISerializable`
- `IComparable`
- `IObservateur`

‚ùå **Mauvais :**
- `Connectable` (manque le I)
- `InterfaceConnectable` (redondant)
- `iConnectable` (I en minuscule)

---

## Le GUID : Identifiant unique

### Qu'est-ce qu'un GUID ?

Un **GUID** (Globally Unique IDentifier) est un code unique qui identifie votre interface de mani√®re universelle. Il ressemble √† ceci :

```pascal
['{8F7A2B3C-4D5E-6F7A-8B9C-0D1E2F3A4B5C}']
```

### Pourquoi utiliser un GUID ?

Le GUID permet :
- D'identifier l'interface de fa√ßon unique dans tout le syst√®me
- D'utiliser certaines fonctionnalit√©s avanc√©es (COM, CORBA)
- D'√©viter les conflits si deux interfaces ont le m√™me nom

### Comment g√©n√©rer un GUID ?

Dans **Lazarus IDE** :
1. Placez votre curseur √† l'endroit o√π vous voulez le GUID
2. Menu : **Outils** ‚Üí **G√©n√©rer un GUID** (ou `Ctrl+Shift+G`)
3. Choisissez le format avec crochets : `['{...}']`
4. Collez-le dans votre code

**Exemple complet :**

```pascal
type
  ICalculateur = interface
    ['{B7F8E4A2-1C9D-4E6F-A3B2-7D8E9F0A1B2C}']
    function Additionner(A, B: Integer): Integer;
    function Soustraire(A, B: Integer): Integer;
  end;
```

---

## D√©claration des m√©thodes dans une interface

### Types de m√©thodes autoris√©es

Une interface peut contenir :
- ‚úÖ Des **proc√©dures** (sans valeur de retour)
- ‚úÖ Des **fonctions** (avec valeur de retour)

Une interface **NE peut PAS** contenir :
- ‚ùå Des variables ou attributs
- ‚ùå Des constructeurs ou destructeurs
- ‚ùå Des propri√©t√©s avec impl√©mentation
- ‚ùå Du code ex√©cutable

### Syntaxe des m√©thodes

```pascal
type
  IGestionnaireFichier = interface
    ['{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}']

    // Proc√©dures (pas de retour)
    procedure Ouvrir(const NomFichier: string);
    procedure Fermer;
    procedure Ecrire(const Donnees: string);

    // Fonctions (avec retour)
    function Lire: string;
    function EstOuvert: Boolean;
    function ObtenirTaille: Int64;
  end;
```

**Points importants :**
- Terminez chaque d√©claration par un point-virgule
- Vous pouvez mettre des param√®tres comme dans une proc√©dure/fonction normale
- Utilisez `const` pour les param√®tres en lecture seule
- Pas de mot-cl√© `public` ou `private` : tout est public

---

## Impl√©mentation d'une interface

### √âtape 1 : D√©clarer la classe

Pour impl√©menter une interface, votre classe doit :
1. H√©riter de `TInterfacedObject` (ou `TObject` avec gestion manuelle)
2. Sp√©cifier l'interface apr√®s une virgule

```pascal
type
  TGestionnaireFichierTexte = class(TInterfacedObject, IGestionnaireFichier)
  private
    FFichier: TextFile;
    FOuvert: Boolean;
  public
    // D√©claration des m√©thodes de l'interface
    procedure Ouvrir(const NomFichier: string);
    procedure Fermer;
    procedure Ecrire(const Donnees: string);
    function Lire: string;
    function EstOuvert: Boolean;
    function ObtenirTaille: Int64;
  end;
```

### √âtape 2 : Impl√©menter toutes les m√©thodes

**R√®gle absolue :** Vous devez impl√©menter **TOUTES** les m√©thodes d√©clar√©es dans l'interface, sinon le code ne compilera pas.

```pascal
implementation

procedure TGestionnaireFichierTexte.Ouvrir(const NomFichier: string);
begin
  AssignFile(FFichier, NomFichier);
  Reset(FFichier);
  FOuvert := True;
end;

procedure TGestionnaireFichierTexte.Fermer;
begin
  if FOuvert then
  begin
    CloseFile(FFichier);
    FOuvert := False;
  end;
end;

procedure TGestionnaireFichierTexte.Ecrire(const Donnees: string);
begin
  if FOuvert then
    WriteLn(FFichier, Donnees);
end;

function TGestionnaireFichierTexte.Lire: string;
begin
  if FOuvert then
    ReadLn(FFichier, Result)
  else
    Result := '';
end;

function TGestionnaireFichierTexte.EstOuvert: Boolean;
begin
  Result := FOuvert;
end;

function TGestionnaireFichierTexte.ObtenirTaille: Int64;
begin
  // Impl√©mentation simplifi√©e
  Result := 0;
end;
```

---

## TInterfacedObject : La classe de base

### Pourquoi h√©riter de TInterfacedObject ?

`TInterfacedObject` est une classe fournie par FreePascal qui :
- Impl√©mente automatiquement la gestion des r√©f√©rences (comptage)
- Fournit les m√©thodes n√©cessaires pour les interfaces (`QueryInterface`, `_AddRef`, `_Release`)
- Simplifie grandement le travail du programmeur

### Syntaxe

```pascal
type
  MaClasse = class(TInterfacedObject, IMonInterface)
    // ...
  end;
```

**Attention √† l'ordre :**
1. D'abord la classe parente (`TInterfacedObject`)
2. Puis l'interface (ou les interfaces) s√©par√©es par des virgules

---

## Impl√©menter plusieurs interfaces

Une classe peut impl√©menter plusieurs interfaces simultan√©ment. Il suffit de les lister s√©par√©es par des virgules :

```pascal
type
  // Premi√®re interface
  ILisible = interface
    ['{F1E2D3C4-B5A6-7890-1234-567890ABCDEF}']
    function Lire: string;
  end;

  // Deuxi√®me interface
  IEcrivable = interface
    ['{A9B8C7D6-E5F4-3210-FEDC-BA9876543210}']
    procedure Ecrire(const Texte: string);
  end;

  // Classe qui impl√©mente les deux
  TFichierComplet = class(TInterfacedObject, ILisible, IEcrivable)
  private
    FContenu: string;
  public
    // M√©thodes de ILisible
    function Lire: string;

    // M√©thodes de IEcrivable
    procedure Ecrire(const Texte: string);
  end;

implementation

function TFichierComplet.Lire: string;
begin
  Result := FContenu;
end;

procedure TFichierComplet.Ecrire(const Texte: string);
begin
  FContenu := Texte;
end;
```

**R√®gle :** Vous devez impl√©menter **toutes** les m√©thodes de **toutes** les interfaces list√©es.

---

## Exemple complet : Syst√®me de notifications

Voici un exemple r√©aliste montrant toute la cha√Æne :

```pascal
unit UNotifications;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils;

type
  // 1. D√âCLARATION DE L'INTERFACE
  INotificateur = interface
    ['{D4C3B2A1-9E8F-7D6C-5B4A-3E2F1D0C9B8A}']
    procedure EnvoyerMessage(const Message: string);
    function ObtenirNomService: string;
  end;

  // 2. IMPL√âMENTATION PAR EMAIL
  TNotificateurEmail = class(TInterfacedObject, INotificateur)
  private
    FAdresseEmail: string;
  public
    constructor Create(const AdresseEmail: string);
    procedure EnvoyerMessage(const Message: string);
    function ObtenirNomService: string;
  end;

  // 3. IMPL√âMENTATION PAR SMS
  TNotificateurSMS = class(TInterfacedObject, INotificateur)
  private
    FNumeroTelephone: string;
  public
    constructor Create(const NumeroTel: string);
    procedure EnvoyerMessage(const Message: string);
    function ObtenirNomService: string;
  end;

implementation

{ TNotificateurEmail }

constructor TNotificateurEmail.Create(const AdresseEmail: string);
begin
  inherited Create;
  FAdresseEmail := AdresseEmail;
end;

procedure TNotificateurEmail.EnvoyerMessage(const Message: string);
begin
  WriteLn('üìß Envoi email √† ', FAdresseEmail);
  WriteLn('   Message: ', Message);
end;

function TNotificateurEmail.ObtenirNomService: string;
begin
  Result := 'Service Email';
end;

{ TNotificateurSMS }

constructor TNotificateurSMS.Create(const NumeroTel: string);
begin
  inherited Create;
  FNumeroTelephone := NumeroTel;
end;

procedure TNotificateurSMS.EnvoyerMessage(const Message: string);
begin
  WriteLn('üì± Envoi SMS au ', FNumeroTelephone);
  WriteLn('   Message: ', Message);
end;

function TNotificateurSMS.ObtenirNomService: string;
begin
  Result := 'Service SMS';
end;

end.
```

**Utilisation :**

```pascal
program TestNotifications;

{$mode objfpc}{$H+}

uses
  UNotifications;

procedure EnvoyerAlerte(Notif: INotificateur; const Alerte: string);
begin
  WriteLn('=== ', Notif.ObtenirNomService, ' ===');
  Notif.EnvoyerMessage(Alerte);
  WriteLn('');
end;

var
  Email: INotificateur;
  SMS: INotificateur;
begin
  // Cr√©ation des notificateurs
  Email := TNotificateurEmail.Create('utilisateur@exemple.com');
  SMS := TNotificateurSMS.Create('+33 6 12 34 56 78');

  // Utilisation via l'interface
  EnvoyerAlerte(Email, 'Nouveau message dans votre bo√Æte');
  EnvoyerAlerte(SMS, 'Code de v√©rification: 123456');

  // Pas besoin de Free : gestion automatique !
end.
```

**R√©sultat :**
```
=== Service Email ===
üìß Envoi email √† utilisateur@exemple.com
   Message: Nouveau message dans votre bo√Æte

=== Service SMS ===
üì± Envoi SMS au +33 6 12 34 56 78
   Message: Code de v√©rification: 123456
```

---

## Bonnes pratiques de d√©claration

### 1. Une interface = Un r√¥le clair

‚úÖ **Bon :** Interfaces sp√©cialis√©es
```pascal
ILecteur = interface      // Responsabilit√©: lire
IEcrivain = interface     // Responsabilit√©: √©crire
IVerifiable = interface   // Responsabilit√©: v√©rifier
```

‚ùå **Mauvais :** Interface fourre-tout
```pascal
IFichier = interface
  procedure Lire;
  procedure Ecrire;
  procedure Verifier;
  procedure Comprimer;
  procedure Chiffrer;
  // ... 20 m√©thodes ...
end;
```

### 2. Noms expressifs

Utilisez des noms qui d√©crivent clairement le comportement :

‚úÖ **Bon :**
- `ISerializable` : peut √™tre s√©rialis√©
- `IComparable` : peut √™tre compar√©
- `IDisposable` : peut √™tre lib√©r√©

‚ùå **Mauvais :**
- `IHelper` (trop vague)
- `IUtility` (ne dit rien)
- `IManager` (trop g√©n√©rique)

### 3. Gardez les interfaces petites

**Principe ISP** (Interface Segregation Principle) :
> Il vaut mieux plusieurs petites interfaces qu'une grosse interface.

```pascal
// ‚úÖ Bon : interfaces s√©par√©es
ILisible = interface
  function Lire: string;
end;

IEcrivable = interface
  procedure Ecrire(const Texte: string);
end;

// Une classe peut impl√©menter les deux si n√©cessaire
TFichier = class(TInterfacedObject, ILisible, IEcrivable)
```

---

## Erreurs courantes et solutions

### Erreur 1 : Oublier d'impl√©menter une m√©thode

**Code :**
```pascal
type
  ITest = interface
    procedure Methode1;
    procedure Methode2;
  end;

  TTest = class(TInterfacedObject, ITest)
  public
    procedure Methode1;
    // Oubli de Methode2 !
  end;
```

**Erreur du compilateur :**
```
Error: No matching implementation for interface method "Methode2" found
```

**Solution :** Impl√©menter toutes les m√©thodes d√©clar√©es dans l'interface.

### Erreur 2 : Signature incorrecte

**Code :**
```pascal
type
  ICalcul = interface
    function Additionner(A, B: Integer): Integer;
  end;

  TCalcul = class(TInterfacedObject, ICalcul)
  public
    // Signature diff√©rente !
    function Additionner(A, B: Double): Double;
  end;
```

**Probl√®me :** Les types de param√®tres ne correspondent pas.

**Solution :** Respecter exactement la signature (noms, types, ordre des param√®tres).

### Erreur 3 : H√©riter de TObject au lieu de TInterfacedObject

**Code :**
```pascal
type
  TTest = class(TObject, ITest)  // ‚ùå TObject au lieu de TInterfacedObject
```

**Probl√®me :** Vous devrez g√©rer manuellement le comptage de r√©f√©rences (complexe pour un d√©butant).

**Solution :** Utiliser `TInterfacedObject` comme classe de base.

---

## R√©capitulatif de la syntaxe

```pascal
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// D√âCLARATION (dans la section interface de l'unit√©)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

type
  // Interface
  INomInterface = interface
    ['{GUID-GENERE-PAR-LAZARUS}']
    procedure MethodeSansRetour(Param: Type);
    function MethodeAvecRetour(Param: Type): TypeRetour;
  end;

  // Classe d'impl√©mentation
  TNomClasse = class(TInterfacedObject, INomInterface)
  private
    // Attributs priv√©s
  public
    // D√©claration des m√©thodes de l'interface
    procedure MethodeSansRetour(Param: Type);
    function MethodeAvecRetour(Param: Type): TypeRetour;
  end;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// IMPL√âMENTATION (dans la section implementation de l'unit√©)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

implementation

procedure TNomClasse.MethodeSansRetour(Param: Type);
begin
  // Code ici
end;

function TNomClasse.MethodeAvecRetour(Param: Type): TypeRetour;
begin
  // Code ici
  Result := ...;
end;
```

---

## R√©sum√©

### D√©claration d'une interface
- Se fait dans la section `type`
- Commence par `I` par convention
- Contient un GUID (g√©n√©r√© par Lazarus)
- Liste uniquement des d√©clarations de m√©thodes
- Pas d'attributs, pas de code

### Impl√©mentation d'une interface
- La classe h√©rite de `TInterfacedObject`
- L'interface est list√©e apr√®s une virgule
- **Toutes** les m√©thodes doivent √™tre impl√©ment√©es
- Les signatures doivent correspondre exactement
- Plusieurs interfaces peuvent √™tre impl√©ment√©es

### Points cl√©s √† retenir
‚úÖ Une interface = un contrat obligatoire
‚úÖ `TInterfacedObject` simplifie le travail
‚úÖ Toujours g√©n√©rer un GUID pour vos interfaces
‚úÖ Respecter les conventions de nommage (I...)
‚úÖ Garder les interfaces simples et cibl√©es

---

## Prochaine √©tape

Dans la section suivante (12.3), vous d√©couvrirez comment utiliser les interfaces pour r√©aliser de l'**h√©ritage multiple**, une fonctionnalit√© puissante que les classes seules ne peuvent pas offrir.

‚è≠Ô∏è [H√©ritage multiple via interfaces](/12-interfaces-poo-avancee/03-heritage-multiple-via-interfaces.md)
