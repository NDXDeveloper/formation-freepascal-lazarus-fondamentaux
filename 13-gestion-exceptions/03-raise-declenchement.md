üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.3 Raise et d√©clenchement

## Introduction

Nous avons vu comment **capturer** les exceptions avec `try-except`. Maintenant, nous allons apprendre √† **d√©clencher** (ou **lever**) nos propres exceptions avec le mot-cl√© `raise`. C'est un outil puissant qui vous permet de signaler qu'une situation anormale s'est produite dans votre code.

## Le mot-cl√© Raise

Le mot-cl√© `raise` permet de d√©clencher volontairement une exception. On dit qu'on "l√®ve" ou "lance" une exception.

### Syntaxe de base

```pascal
raise ClasseException.Create('Message d''erreur');
```

### Exemple simple

```pascal
procedure DiviserParDeux(nombre: Integer);
begin
  if nombre mod 2 <> 0 then
    raise Exception.Create('Le nombre doit √™tre pair !');

  WriteLn('R√©sultat : ', nombre div 2);
end;
```

Lorsque `raise` est ex√©cut√© :
1. L'ex√©cution normale s'arr√™te imm√©diatement
2. Une exception est cr√©√©e avec le message fourni
3. Le programme cherche un bloc `except` pour la g√©rer
4. Si aucun bloc n'est trouv√©, le programme s'arr√™te avec un message d'erreur

## Pourquoi lever des exceptions ?

### 1. Valider les donn√©es

Plut√¥t que de continuer avec des donn√©es invalides, il vaut mieux signaler le probl√®me imm√©diatement.

```pascal
procedure DefinirAge(age: Integer);
begin
  if age < 0 then
    raise Exception.Create('L''√¢ge ne peut pas √™tre n√©gatif');

  if age > 150 then
    raise Exception.Create('L''√¢ge semble irr√©aliste');

  // Si on arrive ici, l'√¢ge est valide
  WriteLn('√Çge d√©fini : ', age);
end;
```

### 2. Signaler l'impossibilit√© d'effectuer une op√©ration

```pascal
function LireFichierConfiguration: String;
var
  f: TextFile;
begin
  AssignFile(f, 'config.ini');

  if not FileExists('config.ini') then
    raise Exception.Create('Fichier de configuration introuvable');

  Reset(f);
  ReadLn(f, Result);
  CloseFile(f);
end;
```

### 3. V√©rifier les pr√©conditions

```pascal
procedure RetirerArgent(montant: Double);
begin
  if montant <= 0 then
    raise Exception.Create('Le montant doit √™tre positif');

  if montant > SoldeCompte then
    raise Exception.Create('Solde insuffisant');

  // Effectuer le retrait
  SoldeCompte := SoldeCompte - montant;
end;
```

## Les classes d'exceptions standard

FreePascal fournit plusieurs classes d'exceptions pr√©d√©finies. Vous pouvez les utiliser avec `raise` :

### Exception g√©n√©rique

```pascal
raise Exception.Create('Une erreur s''est produite');
```

La classe `Exception` est la classe de base. Utilisez-la quand aucune classe sp√©cifique ne convient.

### Exceptions math√©matiques

```pascal
// Division par z√©ro
raise EDivByZero.Create('Division par z√©ro d√©tect√©e');

// D√©passement de capacit√©
raise EOverflow.Create('Le nombre est trop grand');

// Erreur de calcul
raise EMathError.Create('Op√©ration math√©matique invalide');
```

### Exceptions de conversion

```pascal
// Conversion impossible
raise EConvertError.Create('Impossible de convertir "abc" en nombre');
```

### Exceptions d'acc√®s aux donn√©es

```pascal
// Index hors limites
raise ERangeError.Create('Index en dehors des limites du tableau');

// Liste vide
raise EListError.Create('Impossible d''acc√©der √† une liste vide');
```

### Exceptions de fichiers et I/O

```pascal
// Erreur de lecture/√©criture
raise EInOutError.Create('Erreur lors de l''acc√®s au fichier');

// Erreur de flux
raise EStreamError.Create('Erreur lors de la manipulation du flux');
```

## Lever une exception avec format

Parfois, vous voulez inclure des valeurs dans votre message d'erreur. Utilisez `Format` :

```pascal
procedure VerifierAge(age: Integer);
begin
  if (age < 18) or (age > 65) then
    raise Exception.CreateFmt(
      '√Çge invalide : %d. Doit √™tre entre 18 et 65.',
      [age]
    );
end;
```

### Exemples avec Format

```pascal
// Plusieurs valeurs
raise Exception.CreateFmt(
  'Division impossible : %d / %d',
  [numerateur, denominateur]
);

// Avec des cha√Ænes
raise Exception.CreateFmt(
  'Fichier "%s" introuvable dans le r√©pertoire "%s"',
  [nomFichier, repertoire]
);

// M√©lange de types
raise Exception.CreateFmt(
  'L''utilisateur "%s" a √©chou√© %d fois',
  [nomUtilisateur, nombreEchecs]
);
```

## Re-lever une exception

Parfois, vous voulez capturer une exception, faire quelque chose (comme logger l'erreur), puis la re-lancer pour qu'elle soit g√©r√©e √† un niveau sup√©rieur.

### Syntaxe : Raise seul

```pascal
try
  // Code √† risque
except
  on E: Exception do
  begin
    // Faire quelque chose avec l'exception
    WriteLn('Erreur d√©tect√©e : ', E.Message);

    // Re-lever la m√™me exception
    raise;
  end;
end;
```

**Important :** Utilisez `raise;` (sans argument) pour re-lever l'exception actuelle.

### Exemple pratique : logging et re-propagation

```pascal
procedure TraiterFichier(const nomFichier: String);
begin
  try
    // Traitement du fichier
    LireDonnees(nomFichier);
    AnalyserContenu;
    SauvegarderResultat;
  except
    on E: Exception do
    begin
      // Logger l'erreur pour diagnostic
      LoggerErreur(Format('Erreur dans TraiterFichier(%s): %s',
                          [nomFichier, E.Message]));

      // Re-lever l'exception pour que l'appelant puisse la g√©rer
      raise;
    end;
  end;
end;
```

## Lever une exception diff√©rente

Vous pouvez aussi capturer une exception et en lever une autre, plus appropri√©e :

```pascal
function ChargerConfiguration: TConfiguration;
begin
  try
    Result := TConfiguration.Create;
    Result.LoadFromFile('config.xml');
  except
    on E: EFileNotFoundException do
      raise Exception.Create(
        'Impossible de d√©marrer l''application : configuration manquante'
      );
    on E: EXMLError do
      raise Exception.Create(
        'Fichier de configuration corrompu, veuillez le r√©installer'
      );
  end;
end;
```

Ceci est utile pour :
- Traduire une erreur technique en message compr√©hensible pour l'utilisateur
- Masquer les d√©tails d'impl√©mentation
- Fournir un contexte suppl√©mentaire

## Exemple complet : validation d'un formulaire

Voici un exemple r√©aliste combinant plusieurs concepts :

```pascal
procedure ValiderFormulaireInscription(
  const nom, email: String;
  age: Integer
);
begin
  // Validation du nom
  if Trim(nom) = '' then
    raise Exception.Create('Le nom ne peut pas √™tre vide');

  if Length(nom) < 2 then
    raise Exception.Create('Le nom doit contenir au moins 2 caract√®res');

  // Validation de l'email
  if Pos('@', email) = 0 then
    raise Exception.Create('L''adresse email est invalide');

  // Validation de l'√¢ge
  if age < 18 then
    raise Exception.CreateFmt(
      'Vous devez avoir au moins 18 ans (√¢ge actuel : %d)',
      [age]
    );

  if age > 120 then
    raise Exception.CreateFmt(
      'L''√¢ge %d semble incorrect',
      [age]
    );

  // Si on arrive ici, tout est valide
  WriteLn('Inscription valid√©e pour ', nom);
end;

// Utilisation
begin
  try
    ValiderFormulaireInscription('', 'test@example.com', 25);
  except
    on E: Exception do
      WriteLn('Erreur de validation : ', E.Message);
  end;
end;
```

**R√©sultat :**
```
Erreur de validation : Le nom ne peut pas √™tre vide
```

## Quand NE PAS lever d'exception

Les exceptions doivent √™tre r√©serv√©es aux situations **exceptionnelles**. Ne les utilisez pas pour :

### 1. Le flux de contr√¥le normal

```pascal
// ‚úó MAUVAIS
function TrouverElement(valeur: Integer): Boolean;
begin
  try
    // Recherche...
    raise Exception.Create('Pas trouv√©');
  except
    Result := False;
  end;
end;

// ‚úì BON
function TrouverElement(valeur: Integer): Boolean;
begin
  // Recherche...
  Result := False;  // Simple retour de valeur
end;
```

### 2. Les situations pr√©visibles

```pascal
// ‚úó MAUVAIS
function Diviser(a, b: Integer): Integer;
begin
  // Lever une exception √† chaque fois que b = 0
  if b = 0 then
    raise EDivByZero.Create('Division par z√©ro');
  Result := a div b;
end;

// ‚úì BON
function Diviser(a, b: Integer; out resultat: Integer): Boolean;
begin
  if b = 0 then
  begin
    Result := False;  // Retour simple
    Exit;
  end;
  resultat := a div b;
  Result := True;
end;
```

### 3. Les validations simples

Si vous pouvez v√©rifier une condition simplement, faites-le plut√¥t que de lever une exception :

```pascal
// Pour les cas simples
if FileExists(nomFichier) then
  TraiterFichier(nomFichier)
else
  WriteLn('Fichier introuvable');
```

## Hi√©rarchie et cascade d'exceptions

Les exceptions peuvent se propager √† travers plusieurs niveaux de proc√©dures :

```pascal
procedure NiveauProfond;
begin
  raise Exception.Create('Erreur au niveau profond');
end;

procedure NiveauIntermediaire;
begin
  WriteLn('Avant appel niveau profond');
  NiveauProfond;  // L√®ve une exception
  WriteLn('Apr√®s appel - jamais ex√©cut√©');
end;

procedure NiveauSuperieur;
begin
  try
    WriteLn('D√©but du traitement');
    NiveauIntermediaire;
    WriteLn('Fin du traitement - jamais ex√©cut√©');
  except
    on E: Exception do
      WriteLn('Exception captur√©e : ', E.Message);
  end;
  WriteLn('Apr√®s le try-except');
end;
```

**R√©sultat :**
```
D√©but du traitement
Avant appel niveau profond
Exception captur√©e : Erreur au niveau profond
Apr√®s le try-except
```

## Bonnes pratiques

### 1. Messages d'erreur clairs et utiles

```pascal
// ‚úó MAUVAIS
raise Exception.Create('Erreur');

// ‚úì BON
raise Exception.Create('Impossible d''ouvrir le fichier "donnees.txt" : v√©rifiez qu''il existe et que vous avez les droits d''acc√®s');
```

### 2. Utiliser la classe d'exception appropri√©e

```pascal
// ‚úó MOINS BON
if diviseur = 0 then
  raise Exception.Create('Division par z√©ro');

// ‚úì MIEUX
if diviseur = 0 then
  raise EDivByZero.Create('Division par z√©ro');
```

### 3. Lever t√¥t, capturer tard

Levez les exceptions d√®s que vous d√©tectez un probl√®me, mais ne les capturez que l√† o√π vous pouvez faire quelque chose d'utile.

```pascal
// ‚úì BON
function OuvrirFichier(const nom: String): TextFile;
begin
  if not FileExists(nom) then
    raise Exception.Create('Fichier introuvable : ' + nom);  // Lever t√¥t

  // ...
end;

procedure TraiterDonnees;
begin
  try
    // ... appels multiples
  except
    // Capturer tard, au niveau o√π on peut g√©rer
    on E: Exception do
      AfficherMessageUtilisateur(E.Message);
  end;
end;
```

### 4. Ne pas masquer les informations

```pascal
// ‚úó MAUVAIS
try
  TraiterFichier(nom);
except
  raise Exception.Create('Erreur');  // Perte d'information !
end;

// ‚úì BON
try
  TraiterFichier(nom);
except
  on E: Exception do
    raise Exception.Create('Erreur lors du traitement de ' + nom + ': ' + E.Message);
end;
```

## Sch√©ma r√©capitulatif du flux

```
Fonction A
   ‚îÇ
   ‚îú‚îÄ‚ñ∫ Appelle Fonction B
   ‚îÇ      ‚îÇ
   ‚îÇ      ‚îú‚îÄ‚ñ∫ Appelle Fonction C
   ‚îÇ      ‚îÇ      ‚îÇ
   ‚îÇ      ‚îÇ      ‚îî‚îÄ‚ñ∫ raise Exception ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ      ‚îÇ                                ‚îÇ
   ‚îÇ      ‚îÇ      (pas de try-except)       ‚îÇ
   ‚îÇ      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
   ‚îÇ                                       ‚îÇ
   ‚îÇ      (pas de try-except)              ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                                           ‚îÇ
          try-except dans le programme     ‚îÇ
          principal capture ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Conclusion

Le mot-cl√© `raise` vous permet de cr√©er des programmes robustes qui d√©tectent et signalent les erreurs de mani√®re explicite :

- Utilisez `raise` pour signaler les situations anormales
- Choisissez des classes d'exceptions appropri√©es
- Fournissez des messages clairs et informatifs
- Re-levez les exceptions avec `raise;` quand n√©cessaire
- N'utilisez pas les exceptions pour le flux de contr√¥le normal

Combinez `raise` avec les blocs `try-except` que nous avons vus pr√©c√©demment, et vous aurez tous les outils pour g√©rer efficacement les erreurs dans vos programmes.

---

**Points cl√©s √† retenir :**

- `raise` d√©clenche volontairement une exception
- Syntaxe : `raise ClasseException.Create('Message')`
- Utilisez `CreateFmt` pour inclure des valeurs dans le message
- `raise;` (sans argument) re-l√®ve l'exception actuelle
- Les exceptions doivent √™tre r√©serv√©es aux situations exceptionnelles
- Toujours fournir des messages d'erreur clairs et utiles
- Choisir la classe d'exception la plus sp√©cifique possible
- Les exceptions se propagent automatiquement vers les niveaux sup√©rieurs

‚è≠Ô∏è [Hi√©rarchie des exceptions](/13-gestion-exceptions/04-hierarchie-exceptions.md)
