üîù Retour au [Sommaire](/SOMMAIRE.md)

# 10.9 Propri√©t√©s (properties) simples

## Qu'est-ce qu'une propri√©t√© ?

Une **propri√©t√©** (property) est une fonctionnalit√© de Pascal qui permet d'acc√©der √† des attributs priv√©s avec une **syntaxe simple**, tout en gardant le **contr√¥le** offert par les m√©thodes accesseurs (getters/setters).

**Analogie :** Imaginez un thermostat. Vous tournez simplement un bouton (interface simple), mais en interne, il y a des circuits complexes qui v√©rifient et ajustent la temp√©rature (contr√¥le et validation). Les propri√©t√©s fonctionnent de la m√™me mani√®re.

## Le probl√®me que les propri√©t√©s r√©solvent

### Sans propri√©t√©s : m√©thodes accesseurs

```pascal
type
  TPersonne = class
  private
    FNom: string;
    FAge: Integer;
  public
    function ObtenirNom: string;
    procedure DefinirNom(const Valeur: string);
    function ObtenirAge: Integer;
    procedure DefinirAge(Valeur: Integer);
  end;

// Utilisation : syntaxe lourde
var
  P: TPersonne;
begin
  P := TPersonne.Create;
  P.DefinirNom('Alice');           // ‚úó Verbeux
  P.DefinirAge(30);
  WriteLn(P.ObtenirNom);           // ‚úó Verbeux
  WriteLn(P.ObtenirAge);
  P.Free;
end;
```

### Avec propri√©t√©s : syntaxe naturelle

```pascal
type
  TPersonne = class
  private
    FNom: string;
    FAge: Integer;
  public
    property Nom: string read FNom write FNom;
    property Age: Integer read FAge write FAge;
  end;

// Utilisation : syntaxe simple et naturelle
var
  P: TPersonne;
begin
  P := TPersonne.Create;
  P.Nom := 'Alice';      // ‚úì Simple et clair
  P.Age := 30;
  WriteLn(P.Nom);        // ‚úì Comme un attribut
  WriteLn(P.Age);
  P.Free;
end;
```

**Avantage :** La syntaxe est simple comme pour un attribut public, mais on garde le contr√¥le de l'encapsulation.

## Syntaxe de base

### Structure g√©n√©rale

```pascal
property NomPropriete: Type read M√©thodeOuAttributLecture write M√©thodeOuAttributEcriture;
```

**√âl√©ments :**
- `property` : mot-cl√©
- `NomPropriete` : nom de la propri√©t√© (convention : PascalCase, pas de pr√©fixe F)
- `Type` : type de donn√©es de la propri√©t√©
- `read` : comment lire la valeur
- `write` : comment √©crire la valeur (facultatif)

### Exemple minimal

```pascal
type
  TCompteur = class
  private
    FValeur: Integer;
  public
    property Valeur: Integer read FValeur write FValeur;
  end;

var
  C: TCompteur;
begin
  C := TCompteur.Create;
  C.Valeur := 10;        // √âquivaut √† : C.FValeur := 10
  WriteLn(C.Valeur);     // √âquivaut √† : WriteLn(C.FValeur)
  C.Free;
end;
```

## Types de propri√©t√©s

### 1. Propri√©t√© en lecture/√©criture (Read/Write)

La plus courante : on peut lire et √©crire la valeur.

```pascal
type
  TRectangle = class
  private
    FLargeur: Real;
    FHauteur: Real;
  public
    property Largeur: Real read FLargeur write FLargeur;
    property Hauteur: Real read FHauteur write FHauteur;
  end;

var
  R: TRectangle;
begin
  R := TRectangle.Create;
  R.Largeur := 10;     // √âcriture
  R.Hauteur := 5;      // √âcriture
  WriteLn(R.Largeur);  // Lecture
  R.Free;
end;
```

### 2. Propri√©t√© en lecture seule (Read Only)

On peut lire la valeur mais pas la modifier depuis l'ext√©rieur.

```pascal
type
  TCompteur = class
  private
    FValeur: Integer;
  public
    procedure Incrementer;
    property Valeur: Integer read FValeur;  // Pas de write
  end;

procedure TCompteur.Incrementer;
begin
  FValeur := FValeur + 1;
end;

var
  C: TCompteur;
begin
  C := TCompteur.Create;
  C.Incrementer;
  WriteLn(C.Valeur);    // ‚úì OK : lecture
  // C.Valeur := 10;    // ‚úó ERREUR : propri√©t√© en lecture seule
  C.Free;
end;
```

### 3. Propri√©t√© en √©criture seule (Write Only)

Rarement utilis√©e : on peut √©crire mais pas lire.

```pascal
type
  TConfiguration = class
  private
    FMotDePasse: string;
  public
    property MotDePasse: string write FMotDePasse;  // Pas de read
  end;

var
  Config: TConfiguration;
begin
  Config := TConfiguration.Create;
  Config.MotDePasse := 'secret123';  // ‚úì OK : √©criture
  // WriteLn(Config.MotDePasse);     // ‚úó ERREUR : propri√©t√© en √©criture seule
  Config.Free;
end;
```

## Propri√©t√©s avec m√©thodes accesseurs

### Getter (m√©thode de lecture)

Au lieu d'acc√©der directement √† l'attribut, on peut utiliser une m√©thode :

```pascal
type
  TPersonne = class
  private
    FNom: string;
    FPrenom: string;
    function GetNomComplet: string;  // Getter
  public
    property NomComplet: string read GetNomComplet;
  end;

function TPersonne.GetNomComplet: string;
begin
  Result := FPrenom + ' ' + FNom;
end;

var
  P: TPersonne;
begin
  P := TPersonne.Create;
  P.FPrenom := 'Marie';
  P.FNom := 'Curie';
  WriteLn(P.NomComplet);  // Appelle GetNomComplet, affiche : "Marie Curie"
  P.Free;
end;
```

### Setter (m√©thode d'√©criture)

Pour valider ou traiter les donn√©es avant de les stocker :

```pascal
type
  TPersonne = class
  private
    FAge: Integer;
    procedure SetAge(Valeur: Integer);  // Setter
  public
    property Age: Integer read FAge write SetAge;
  end;

procedure TPersonne.SetAge(Valeur: Integer);
begin
  if (Valeur >= 0) and (Valeur <= 150) then
    FAge := Valeur
  else
  begin
    WriteLn('Erreur : √¢ge invalide (', Valeur, ')');
    FAge := 0;
  end;
end;

var
  P: TPersonne;
begin
  P := TPersonne.Create;
  P.Age := 30;      // Appelle SetAge(30), valide et accepte
  P.Age := -5;      // Appelle SetAge(-5), rejette et met √† 0
  P.Age := 200;     // Appelle SetAge(200), rejette et met √† 0
  WriteLn(P.Age);   // Affiche : 0
  P.Free;
end;
```

### Getter et Setter combin√©s

```pascal
type
  TRectangle = class
  private
    FLargeur: Real;
    function GetSurface: Real;
    procedure SetLargeur(Valeur: Real);
  public
    property Largeur: Real read FLargeur write SetLargeur;
    property Surface: Real read GetSurface;  // Lecture seule calcul√©e
  end;

procedure TRectangle.SetLargeur(Valeur: Real);
begin
  if Valeur > 0 then
    FLargeur := Valeur
  else
    raise Exception.Create('Largeur doit √™tre positive');
end;

function TRectangle.GetSurface: Real;
begin
  Result := FLargeur * FHauteur;
end;
```

## Propri√©t√©s calcul√©es

Une propri√©t√© peut √™tre calcul√©e √† la vol√©e sans avoir d'attribut correspondant :

```pascal
type
  TCercle = class
  private
    FRayon: Real;
    function GetDiametre: Real;
    procedure SetDiametre(Valeur: Real);
    function GetCirconference: Real;
    function GetSurface: Real;
  public
    property Rayon: Real read FRayon write FRayon;
    property Diametre: Real read GetDiametre write SetDiametre;
    property Circonference: Real read GetCirconference;  // Calcul√©e, lecture seule
    property Surface: Real read GetSurface;              // Calcul√©e, lecture seule
  end;

function TCercle.GetDiametre: Real;
begin
  Result := FRayon * 2;
end;

procedure TCercle.SetDiametre(Valeur: Real);
begin
  FRayon := Valeur / 2;
end;

function TCercle.GetCirconference: Real;
const
  PI = 3.14159265359;
begin
  Result := 2 * PI * FRayon;
end;

function TCercle.GetSurface: Real;
const
  PI = 3.14159265359;
begin
  Result := PI * FRayon * FRayon;
end;

// Utilisation
var
  C: TCercle;
begin
  C := TCercle.Create;

  C.Rayon := 5;
  WriteLn('Rayon : ', C.Rayon:0:2);
  WriteLn('Diam√®tre : ', C.Diametre:0:2);       // Calcul√© automatiquement
  WriteLn('Circonf√©rence : ', C.Circonference:0:2);  // Calcul√© automatiquement
  WriteLn('Surface : ', C.Surface:0:2);         // Calcul√© automatiquement

  WriteLn;

  // On peut aussi d√©finir le diam√®tre
  C.Diametre := 20;
  WriteLn('Nouveau rayon : ', C.Rayon:0:2);     // Affiche : 10.00

  C.Free;
end;
```

## Conventions de nommage

### Pour les attributs

```pascal
private
  FNom: string;        // ‚úì Pr√©fixe F (Field)
  FAge: Integer;
  FEstActif: Boolean;
```

### Pour les propri√©t√©s

```pascal
public
  property Nom: string ...       // ‚úì Pas de pr√©fixe, PascalCase
  property Age: Integer ...
  property EstActif: Boolean ...
```

### Pour les getters/setters

```pascal
private
  function GetNom: string;       // ‚úì Get + nom de la propri√©t√©
  procedure SetNom(const Valeur: string);  // ‚úì Set + nom de la propri√©t√©

  function GetAge: Integer;
  procedure SetAge(Valeur: Integer);
```

## Exemple complet : Classe TCompteBancaire

```pascal
program ExempleProperties;

{$mode objfpc}{$H+}

uses
  SysUtils;

type
  TCompteBancaire = class
  private
    FNumeroCompte: string;
    FSolde: Real;
    FTitulaire: string;
    FTauxInteret: Real;
    FHistorique: array of string;

    // Getters
    function GetSoldeFormate: string;
    function GetInteretsAnnuels: Real;
    function GetNombreOperations: Integer;

    // Setters
    procedure SetTitulaire(const Valeur: string);
    procedure SetTauxInteret(Valeur: Real);

    // M√©thode priv√©e
    procedure AjouterHistorique(const Operation: string);

  public
    constructor Create(const NumeroCompte, Titulaire: string; SoldeInitial: Real);
    destructor Destroy; override;

    procedure Crediter(Montant: Real);
    procedure Debiter(Montant: Real);
    procedure AfficherHistorique;

    // Propri√©t√©s
    property NumeroCompte: string read FNumeroCompte;  // Lecture seule
    property Solde: Real read FSolde;                  // Lecture seule
    property SoldeFormate: string read GetSoldeFormate; // Calcul√©e
    property Titulaire: string read FTitulaire write SetTitulaire;
    property TauxInteret: Real read FTauxInteret write SetTauxInteret;
    property InteretsAnnuels: Real read GetInteretsAnnuels;  // Calcul√©e
    property NombreOperations: Integer read GetNombreOperations;  // Calcul√©e
  end;

// === IMPL√âMENTATION ===

constructor TCompteBancaire.Create(const NumeroCompte, Titulaire: string; SoldeInitial: Real);
begin
  inherited Create;
  FNumeroCompte := NumeroCompte;
  FTitulaire := Titulaire;
  FSolde := SoldeInitial;
  FTauxInteret := 0.02;  // 2% par d√©faut
  SetLength(FHistorique, 0);
  AjouterHistorique('Ouverture du compte avec solde : ' + FloatToStr(SoldeInitial) + ' ‚Ç¨');
end;

destructor TCompteBancaire.Destroy;
begin
  SetLength(FHistorique, 0);
  inherited Destroy;
end;

procedure TCompteBancaire.AjouterHistorique(const Operation: string);
var
  Index: Integer;
begin
  Index := Length(FHistorique);
  SetLength(FHistorique, Index + 1);
  FHistorique[Index] := FormatDateTime('yyyy-mm-dd hh:nn:ss', Now) + ' - ' + Operation;
end;

function TCompteBancaire.GetSoldeFormate: string;
begin
  Result := FormatFloat('#,##0.00', FSolde) + ' ‚Ç¨';
end;

function TCompteBancaire.GetInteretsAnnuels: Real;
begin
  Result := FSolde * FTauxInteret;
end;

function TCompteBancaire.GetNombreOperations: Integer;
begin
  Result := Length(FHistorique);
end;

procedure TCompteBancaire.SetTitulaire(const Valeur: string);
begin
  if Length(Valeur) > 0 then
  begin
    FTitulaire := Valeur;
    AjouterHistorique('Changement de titulaire : ' + Valeur);
  end
  else
    WriteLn('Erreur : nom de titulaire invalide');
end;

procedure TCompteBancaire.SetTauxInteret(Valeur: Real);
begin
  if (Valeur >= 0) and (Valeur <= 0.10) then  // Max 10%
  begin
    FTauxInteret := Valeur;
    AjouterHistorique('Nouveau taux d''int√©r√™t : ' + FloatToStr(Valeur * 100) + '%');
  end
  else
    WriteLn('Erreur : taux d''int√©r√™t invalide (doit √™tre entre 0 et 10%)');
end;

procedure TCompteBancaire.Crediter(Montant: Real);
begin
  if Montant > 0 then
  begin
    FSolde := FSolde + Montant;
    AjouterHistorique('Cr√©dit de ' + FloatToStr(Montant) + ' ‚Ç¨');
    WriteLn('Cr√©dit effectu√© : ', Montant:0:2, ' ‚Ç¨');
  end
  else
    WriteLn('Erreur : montant invalide');
end;

procedure TCompteBancaire.Debiter(Montant: Real);
begin
  if Montant > 0 then
  begin
    if FSolde >= Montant then
    begin
      FSolde := FSolde - Montant;
      AjouterHistorique('D√©bit de ' + FloatToStr(Montant) + ' ‚Ç¨');
      WriteLn('D√©bit effectu√© : ', Montant:0:2, ' ‚Ç¨');
    end
    else
      WriteLn('Erreur : solde insuffisant');
  end
  else
    WriteLn('Erreur : montant invalide');
end;

procedure TCompteBancaire.AfficherHistorique;
var
  I: Integer;
begin
  WriteLn('=== Historique du compte ', FNumeroCompte, ' ===');
  for I := 0 to High(FHistorique) do
    WriteLn(FHistorique[I]);
  WriteLn('==========================================');
end;

// === PROGRAMME PRINCIPAL ===

var
  Compte: TCompteBancaire;
begin
  WriteLn('=== Cr√©ation du compte ===');
  Compte := TCompteBancaire.Create('FR123456789', 'Jean Dupont', 1000);
  WriteLn;

  WriteLn('=== Affichage des propri√©t√©s ===');
  WriteLn('Num√©ro : ', Compte.NumeroCompte);           // Lecture seule
  WriteLn('Titulaire : ', Compte.Titulaire);
  WriteLn('Solde : ', Compte.Solde:0:2, ' ‚Ç¨');
  WriteLn('Solde format√© : ', Compte.SoldeFormate);    // Propri√©t√© calcul√©e
  WriteLn('Taux d''int√©r√™t : ', (Compte.TauxInteret * 100):0:2, '%');
  WriteLn('Int√©r√™ts annuels : ', Compte.InteretsAnnuels:0:2, ' ‚Ç¨');  // Calcul√©e
  WriteLn('Nombre d''op√©rations : ', Compte.NombreOperations);
  WriteLn;

  WriteLn('=== Op√©rations ===');
  Compte.Crediter(500);
  Compte.Debiter(200);
  WriteLn('Nouveau solde : ', Compte.SoldeFormate);
  WriteLn;

  WriteLn('=== Modification des propri√©t√©s ===');
  Compte.Titulaire := 'Marie Dupont';  // Utilise SetTitulaire avec validation
  Compte.TauxInteret := 0.03;          // 3%, utilise SetTauxInteret
  WriteLn('Nouveau titulaire : ', Compte.Titulaire);
  WriteLn('Nouveau taux : ', (Compte.TauxInteret * 100):0:2, '%');
  WriteLn('Nouveaux int√©r√™ts annuels : ', Compte.InteretsAnnuels:0:2, ' ‚Ç¨');
  WriteLn;

  WriteLn('=== Tentative de modification invalide ===');
  Compte.TauxInteret := 0.15;  // Trop √©lev√©, sera rejet√©
  WriteLn;

  // Tentative d'√©criture sur propri√©t√© en lecture seule (d√©commentez pour voir l'erreur)
  // Compte.Solde := 5000;  // ‚úó ERREUR de compilation
  // Compte.NumeroCompte := 'AUTRE';  // ‚úó ERREUR de compilation

  Compte.AfficherHistorique;
  WriteLn;

  Compte.Free;
  WriteLn('Programme termin√©');
end.
```

## Propri√©t√©s et tableaux

Vous pouvez cr√©er des propri√©t√©s pour acc√©der aux √©l√©ments d'un tableau :

```pascal
type
  TListeNombres = class
  private
    FNombres: array of Integer;
    function GetNombre(Index: Integer): Integer;
    procedure SetNombre(Index: Integer; Valeur: Integer);
    function GetTaille: Integer;
  public
    constructor Create(Taille: Integer);
    property Nombres[Index: Integer]: Integer read GetNombre write SetNombre; default;
    property Taille: Integer read GetTaille;
  end;

constructor TListeNombres.Create(Taille: Integer);
begin
  inherited Create;
  SetLength(FNombres, Taille);
end;

function TListeNombres.GetNombre(Index: Integer): Integer;
begin
  if (Index >= 0) and (Index < Length(FNombres)) then
    Result := FNombres[Index]
  else
    raise Exception.Create('Index hors limites');
end;

procedure TListeNombres.SetNombre(Index: Integer; Valeur: Integer);
begin
  if (Index >= 0) and (Index < Length(FNombres)) then
    FNombres[Index] := Valeur
  else
    raise Exception.Create('Index hors limites');
end;

function TListeNombres.GetTaille: Integer;
begin
  Result := Length(FNombres);
end;

// Utilisation
var
  Liste: TListeNombres;
  I: Integer;
begin
  Liste := TListeNombres.Create(5);

  // Remplissage
  for I := 0 to Liste.Taille - 1 do
    Liste.Nombres[I] := I * 10;  // Utilise SetNombre

  // Lecture
  for I := 0 to Liste.Taille - 1 do
    WriteLn('Nombres[', I, '] = ', Liste.Nombres[I]);  // Utilise GetNombre

  Liste.Free;
end;
```

## Avantages des propri√©t√©s

### 1. Syntaxe simple

```pascal
// Avec propri√©t√©s
P.Age := 30;
WriteLn(P.Age);

// Sans propri√©t√©s (m√©thodes)
P.DefinirAge(30);
WriteLn(P.ObtenirAge);
```

### 2. Validation transparente

```pascal
P.Age := -5;  // Le setter valide et rejette automatiquement
```

### 3. Propri√©t√©s calcul√©es

```pascal
WriteLn(Cercle.Surface);  // Calcul√© √† la vol√©e, pas d'attribut n√©cessaire
```

### 4. √âvolution du code

Vous pouvez commencer avec un acc√®s direct, puis ajouter de la validation plus tard :

```pascal
// Version 1 : acc√®s direct
property Age: Integer read FAge write FAge;

// Version 2 : avec validation (le code utilisant la propri√©t√© ne change pas)
property Age: Integer read FAge write SetAge;
```

### 5. Lecture seule

```pascal
property NumeroCompte: string read FNumeroCompte;  // Protection simple
```

## Bonnes pratiques

### 1. Nommer les propri√©t√©s sans pr√©fixe

```pascal
// ‚úì BON
property Nom: string read FNom write FNom;

// ‚úó MAUVAIS
property FNom: string read FNom write FNom;
```

### 2. Attributs priv√©s + propri√©t√©s publiques

```pascal
type
  TClasse = class
  private
    FValeur: Integer;  // ‚úì Attribut priv√©
  public
    property Valeur: Integer read FValeur write FValeur;  // ‚úì Propri√©t√© publique
  end;
```

### 3. Utiliser des setters pour la validation

```pascal
private
  procedure SetAge(Valeur: Integer);
public
  property Age: Integer read FAge write SetAge;  // ‚úì Validation via setter
```

### 4. Propri√©t√©s calcul√©es en lecture seule

```pascal
// ‚úì BON : propri√©t√© calcul√©e sans setter
property Surface: Real read GetSurface;

// ‚úó Pas de sens : on ne peut pas "d√©finir" une surface calcul√©e
// property Surface: Real read GetSurface write SetSurface;
```

### 5. Documenter les propri√©t√©s

```pascal
type
  TPersonne = class
  public
    // Obtient ou d√©finit le nom de la personne
    // Le nom ne peut pas √™tre vide
    property Nom: string read FNom write SetNom;

    // Obtient l'√¢ge en ann√©es
    // Calcul√© √† partir de la date de naissance
    property Age: Integer read GetAge;
  end;
```

## Erreurs courantes √† √©viter

### Erreur n¬∞1 : Acc√®s direct √† l'attribut au lieu de la propri√©t√©

```pascal
// ‚úó MAUVAIS : contourne la validation
MonObjet.FAge := -5;

// ‚úì BON : utilise la propri√©t√© avec validation
MonObjet.Age := -5;
```

### Erreur n¬∞2 : Setter qui ne fait rien

```pascal
// ‚úó MAUVAIS : setter inutile
procedure TPersonne.SetNom(const Valeur: string);
begin
  FNom := Valeur;  // Pas de validation, autant utiliser l'acc√®s direct
end;

// ‚úì MIEUX : acc√®s direct si pas de validation
property Nom: string read FNom write FNom;
```

### Erreur n¬∞3 : Oublier le const pour les strings

```pascal
// ‚úó Moins efficace
procedure SetNom(Valeur: string);

// ‚úì BON : √©vite la copie
procedure SetNom(const Valeur: string);
```

### Erreur n¬∞4 : Propri√©t√© en √©criture avec calcul complexe

```pascal
// ‚úó D√âCONSEILL√â : setter avec calcul lourd
function TClasse.SetValeurComplexe(Valeur: Integer);
begin
  // Calculs tr√®s lourds...
  FValeur := /* r√©sultat */;
end;

// ‚úì MIEUX : m√©thode explicite
procedure TClasse.CalculerEtDefinirValeur(Valeur: Integer);
```

### Erreur n¬∞5 : M√©langer acc√®s direct et propri√©t√©s

```pascal
type
  TClasse = class
  public
    Attribut1: Integer;  // ‚úó Acc√®s direct
    property Attribut2: Integer read FAttribut2 write FAttribut2;  // Propri√©t√©
  end;

// ‚úì MIEUX : coh√©rence
type
  TClasse = class
  private
    FAttribut1: Integer;
    FAttribut2: Integer;
  public
    property Attribut1: Integer read FAttribut1 write FAttribut1;
    property Attribut2: Integer read FAttribut2 write FAttribut2;
  end;
```

## Propri√©t√©s vs M√©thodes : quand utiliser quoi ?

### Utilisez une propri√©t√© quand :

- Vous acc√©dez √† une **valeur** (comme un attribut)
- L'op√©ration est **rapide** et sans effet de bord majeur
- La syntaxe `Objet.Propriete` est naturelle

```pascal
property Nom: string read FNom write SetNom;
property Age: Integer read GetAge;
property Surface: Real read GetSurface;
```

### Utilisez une m√©thode quand :

- L'op√©ration est **complexe** ou **co√ªteuse**
- L'op√©ration a des **effets de bord** importants
- Vous avez besoin de **plusieurs param√®tres**

```pascal
procedure CalculerStatistiquesCompletes;  // Op√©ration lourde
procedure EnvoyerEmail(const Destinataire, Sujet: string);  // Plusieurs param√®tres
function TrouverUtilisateur(ID: Integer): TUtilisateur;  // Action explicite
```

## Points cl√©s √† retenir

- Les **propri√©t√©s** combinent simplicit√© d'acc√®s et contr√¥le
- Syntaxe : `property Nom: Type read ... write ...;`
- **read** : comment lire (attribut ou m√©thode getter)
- **write** : comment √©crire (attribut ou m√©thode setter)
- Les propri√©t√©s peuvent √™tre **en lecture seule**, **en √©criture seule**, ou **lecture/√©criture**
- Les **propri√©t√©s calcul√©es** n'ont pas d'attribut correspondant
- Toujours mettre les attributs en **private** et utiliser des propri√©t√©s **public**
- Utiliser des **setters** pour valider les donn√©es
- Nommer les propri√©t√©s sans pr√©fixe (pas de F)
- Les propri√©t√©s offrent une **√©volution** facile du code

## Vers la suite

Dans la section suivante, nous aborderons la **comparaison entre programmation proc√©durale et programmation orient√©e objet**, ce qui vous permettra de mieux comprendre quand et pourquoi utiliser l'approche objet plut√¥t que l'approche proc√©durale.

‚è≠Ô∏è [Comparaison proc√©dural vs objet](10-fondamentaux-poo/10-comparaison-procedural-vs-objet.md)
