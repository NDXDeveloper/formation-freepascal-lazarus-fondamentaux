# Formation FreePascal/Lazarus - De Débutant à Intermédiaire
## Edition Multi-plateforme Windows/Ubuntu

---

# PARTIE I : FONDAMENTAUX (Niveau Débutant)

## 1. [Prérequis et Bases de la Programmation](01-prerequis-bases-programmation/README.md)

- 1.1 [Concepts fondamentaux de l'informatique](01-prerequis-bases-programmation/01-concepts-fondamentaux-informatique.md)
- 1.2 [Qu'est-ce qu'un programme ?](01-prerequis-bases-programmation/02-quest-ce-qu-un-programme.md)
- 1.3 [Systèmes de numération et représentation des données](01-prerequis-bases-programmation/03-systemes-numeration-representation-donnees.md)
- 1.4 [Logique booléenne et tables de vérité](01-prerequis-bases-programmation/04-logique-booleenne-tables-verite.md)
- 1.5 [Algorithmes et pseudo-code](01-prerequis-bases-programmation/05-algorithmes-pseudo-code.md)
- 1.6 [Organigrammes et structuration de la pensée](01-prerequis-bases-programmation/06-organigrammes-structuration-pensee.md)
- 1.7 [Introduction aux systèmes d'exploitation](01-prerequis-bases-programmation/07-introduction-systemes-exploitation.md)
- 1.8 [Ligne de commande Windows et Linux basics](01-prerequis-bases-programmation/08-ligne-commande-windows-linux-basics.md)
- 1.9 [Éditeurs de texte et environnements de développement](01-prerequis-bases-programmation/09-editeurs-texte-environnements-developpement.md)
- 1.10 [Premier programme "Hello World" en Pascal](01-prerequis-bases-programmation/10-premier-programme-hello-world-pascal.md)

## 2. [Introduction au Langage Pascal](02-introduction-langage-pascal/README.md)

- 2.1 Histoire du Pascal et son créateur Niklaus Wirth
- 2.2 Structure d'un programme Pascal
- 2.3 Variables et constantes
- 2.4 Types de données primitifs (Integer, Real, Boolean, Char)
- 2.5 Opérateurs arithmétiques et logiques
- 2.6 Entrées/Sorties console (Read, Write, ReadLn, WriteLn)
- 2.7 Formatage de sortie
- 2.8 Commentaires et documentation du code
- 2.9 Conventions de nommage

## 3. [Structures de Contrôle](03-structures-controle/README.md)

- 3.1 Instructions conditionnelles (if-then-else)
- 3.2 Instructions de choix multiple (case-of)
- 3.3 Boucles compteur (for-do)
- 3.4 Boucles conditionnelles (while-do, repeat-until)
- 3.5 Instructions break et continue
- 3.6 Imbrication de structures
- 3.7 Gestion des erreurs simples
- 3.8 Validation des entrées utilisateur
- 3.9 Débogage pas à pas

## 4. [Procédures et Fonctions](04-procedures-fonctions/README.md)

- 4.1 Différence entre procédure et fonction
- 4.2 Déclaration et appel
- 4.3 Paramètres par valeur
- 4.4 Paramètres par référence (var)
- 4.5 Paramètres constants (const)
- 4.6 Paramètres par défaut
- 4.7 Surcharge de procédures/fonctions
- 4.8 Variables locales vs globales
- 4.9 Récursivité
- 4.10 Fonctions prédéfinies utiles
- 4.11 Organisation modulaire du code

## 5. [Types de Données Structurés](05-types-donnees-structures/README.md)

- 5.1 Tableaux statiques unidimensionnels
- 5.2 Tableaux multidimensionnels
- 5.3 Chaînes de caractères (String, ShortString)
- 5.4 Enregistrements (Records)
- 5.5 Enregistrements imbriqués
- 5.6 Tableaux d'enregistrements
- 5.7 Types énumérés
- 5.8 Types ensemble (Set)
- 5.9 Types intervalle
- 5.10 Définition de types personnalisés (Type)

## 6. [Pointeurs et Gestion Mémoire Basique](06-pointeurs-gestion-memoire-basique/README.md)

- 6.1 Concept de pointeur et adresse mémoire
- 6.2 Déclaration et utilisation de pointeurs
- 6.3 Allocation dynamique (New, Dispose)
- 6.4 Pointeurs et tableaux
- 6.5 Pointeurs et enregistrements
- 6.6 Listes chaînées simples
- 6.7 Arbres binaires basics
- 6.8 Fuites mémoire et bonnes pratiques
- 6.9 Débogage des problèmes mémoire

## 7. [Unités et Organisation du Code](07-unites-organisation-code/README.md)

- 7.1 Concept d'unité en Pascal
- 7.2 Structure d'une unité (interface/implementation)
- 7.3 Clauses Uses et dépendances
- 7.4 Ordre de compilation
- 7.5 Variables et procédures publiques/privées
- 7.6 Sections initialization et finalization
- 7.7 Unités standard du RTL
- 7.8 Création de bibliothèques réutilisables
- 7.9 Documentation des unités

## 8. [Gestion des Fichiers et I/O](08-gestion-fichiers-io/README.md)

- 8.1 Types de fichiers (texte, binaire, typé)
- 8.2 Fichiers texte : ouverture, lecture, écriture
- 8.3 Fichiers binaires et accès direct
- 8.4 Fichiers typés
- 8.5 Gestion des erreurs I/O
- 8.6 Manipulation de répertoires
- 8.7 Chemins et noms de fichiers
- 8.8 Fichiers INI pour configuration
- 8.9 Introduction aux streams

## 9. [Introduction à FreePascal et Lazarus](09-introduction-freepascal-lazarus/README.md)

- 9.1 Histoire et philosophie du projet FreePascal
- 9.2 Différences avec Turbo Pascal
- 9.3 L'écosystème Lazarus
- 9.4 Installation sur Windows
- 9.5 Installation sur Ubuntu/Linux
- 9.6 Premier projet avec Lazarus IDE
- 9.7 Structure d'un projet Lazarus
- 9.8 Compilation et exécution
- 9.9 Configuration de base de l'IDE
- 9.10 Utilisation de l'aide et documentation

---

# PARTIE II : PROGRAMMATION ORIENTÉE OBJET (Niveau Intermédiaire)

## 10. [Fondamentaux de la POO](10-fondamentaux-poo/README.md)

- 10.1 Concepts : Classes et Objets
- 10.2 Encapsulation et visibilité
- 10.3 Déclaration de classes
- 10.4 Attributs et méthodes
- 10.5 Constructeurs (Create)
- 10.6 Destructeurs (Destroy, Free)
- 10.7 Self et référence à l'objet courant
- 10.8 Visibilité : private, protected, public, published
- 10.9 Propriétés (properties) simples
- 10.10 Comparaison procédural vs objet
- 10.11 UML et diagrammes de classes basics

## 11. [POO Avancée - Héritage](11-poo-avancee-heritage/README.md)

- 11.1 Concept d'héritage
- 11.2 Classes dérivées
- 11.3 Redéfinition de méthodes
- 11.4 Méthodes virtuelles et override
- 11.5 Méthodes abstraites et classes abstraites
- 11.6 Polymorphisme
- 11.7 Transtypage (as, is)
- 11.8 Inherited et appel au parent
- 11.9 Hiérarchies de classes
- 11.10 Classe TObject et hiérarchie Pascal

## 12. [Interfaces et POO Avancée](12-interfaces-poo-avancee/README.md)

- 12.1 Concept d'interface
- 12.2 Déclaration et implémentation
- 12.3 Héritage multiple via interfaces
- 12.4 IInterface et IUnknown
- 12.5 Comptage de références
- 12.6 Interfaces vs classes abstraites
- 12.7 Delegation et composition
- 12.8 Properties avec getters/setters
- 12.9 Méthodes de classe (class methods)
- 12.10 Design patterns basics (Singleton, Factory)

## 13. [Gestion des Exceptions](13-gestion-exceptions/README.md)

- 13.1 Concept d'exception
- 13.2 Try-except-finally
- 13.3 Raise et déclenchement
- 13.4 Hiérarchie des exceptions
- 13.5 Exceptions personnalisées
- 13.6 Exceptions et ressources
- 13.7 Bonnes pratiques
- 13.8 Débogage avec exceptions
- 13.9 Logging des erreurs

## 14. [Introduction aux Applications Graphiques](14-introduction-applications-graphiques/README.md)

- 14.1 Programmation événementielle concepts
- 14.2 Première application fenêtrée
- 14.3 Formulaires (TForm)
- 14.4 Composants de base (TButton, TEdit, TLabel)
- 14.5 Événements et handlers
- 14.6 Propriétés des composants
- 14.7 Layouts et anchors
- 14.8 Menus et barres d'outils
- 14.9 Boîtes de dialogue standard

## 15. [Composants LCL Fondamentaux](15-composants-lcl-fondamentaux/README.md)

- 15.1 Architecture de la LCL
- 15.2 Hiérarchie des composants
- 15.3 Conteneurs (TPanel, TGroupBox, TPageControl)
- 15.4 Listes (TListBox, TComboBox, TTreeView)
- 15.5 Grilles (TStringGrid, TDrawGrid)
- 15.6 Composants de saisie avancés
- 15.7 Composants d'affichage (TImage, TShape)
- 15.8 Timers et traitement asynchrone
- 15.9 Actions et TActionList

---

# PARTIE III : CONSOLIDATION DES COMPÉTENCES INTERMÉDIAIRES

## 16. [Bases de Données - Maîtrise Approfondie](16-bases-donnees-maitrise-approfondie/README.md)

- 16.1 Concepts des bases de données relationnelles
- 16.2 Introduction au SQL
- 16.3 SQLite : base embarquée
- 16.4 Composants de connexion
- 16.5 TSQLQuery et requêtes
- 16.6 Composants data-aware
- 16.7 Navigation dans les données
- 16.8 Ajout, modification, suppression
- 16.9 Transactions basics
- 16.10 Introduction aux bases Client/Serveur (concepts)
- 16.11 **Connexion à PostgreSQL ou MariaDB**
- 16.12 Gestion avancée des transactions (BEGIN, COMMIT, ROLLBACK)
- 16.13 Gestion des erreurs de connexion et résilience

## 17. [Communications Réseau et API REST](17-communications-reseau-api-rest/README.md)

- 17.1 Concepts fondamentaux : protocole HTTP
- 17.2 Méthodes HTTP (GET, POST, PUT, DELETE)
- 17.3 Introduction aux API REST
- 17.4 Format JSON : structure et syntaxe
- 17.5 Utilisation de TFPHttpClient
- 17.6 Consommation d'API publiques
- 17.7 Parsing JSON avec fpjson
- 17.8 Gestion des erreurs réseau
- 17.9 Headers et authentification basique

## 18. [Introduction Pratique au Multi-threading](18-introduction-pratique-multi-threading/README.md)

- 18.1 Problème : le gel des interfaces graphiques
- 18.2 Concepts de processus et threads
- 18.3 La classe TThread : création et utilisation
- 18.4 Cycle de vie d'un thread
- 18.5 TThread.Synchronize : communication thread-UI
- 18.6 TThread.Queue vs Synchronize
- 18.7 Variables partagées et section critique
- 18.8 Barres de progression et feedback utilisateur
- 18.9 Annulation d'opérations longues

## 19. [Développement Multi-plateforme en Pratique](19-developpement-multi-plateforme-pratique/README.md)

- 19.1 Différences Windows/Linux à connaître
- 19.2 Gestion portable des chemins (PathDelim, DirectorySeparator)
- 19.3 Directives de compilation conditionnelle {$IFDEF}
- 19.4 Unités spécifiques par plateforme
- 19.5 Configuration de projets multi-cibles dans Lazarus
- 19.6 Cross-compilation : théorie et pratique
- 19.7 Gestion des dépendances externes
- 19.8 Tests sur différentes plateformes
- 19.9 Empaquetage et distribution

## 20. [Débogage et Optimisation](20-debogage-optimisation/README.md)

- 20.1 Utilisation avancée du débogueur Lazarus
- 20.2 Points d'arrêt conditionnels
- 20.3 Inspection de variables et expressions
- 20.4 Profiling basique : identifier les goulots
- 20.5 Optimisation des algorithmes courants
- 20.6 Gestion efficace de la mémoire
- 20.7 Outils de détection de fuites mémoire
- 20.8 Logging structuré et niveaux de log
- 20.9 Tests unitaires avec FPCUnit (introduction)



