üîù Retour au [Sommaire](/SOMMAIRE.md)

# 3.8 Validation des entr√©es utilisateur

## Introduction

La validation des entr√©es utilisateur est l'une des comp√©tences les plus importantes en programmation. Les utilisateurs peuvent (intentionnellement ou non) entrer n'importe quoi : des valeurs hors limites, des caract√®res invalides, des formats incorrects... Un programme robuste doit **toujours** v√©rifier et valider les donn√©es avant de les utiliser.

**Le principe fondamental :** Ne faites JAMAIS confiance aux entr√©es utilisateur. Validez tout, tout le temps.

**Analogie :** C'est comme un contr√¥le de s√©curit√© √† l'a√©roport. M√™me si 99% des passagers sont en r√®gle, on v√©rifie chacun d'eux syst√©matiquement.

## Pourquoi valider les entr√©es ?

### Sans validation

```pascal
program SansValidation;
var
  age: Integer;
begin
  Write('√Çge : ');
  ReadLn(age);
  WriteLn('Dans 10 ans, vous aurez ', age + 10, ' ans');
  ReadLn;
end.
```

**Probl√®mes possibles :**
- L'utilisateur entre -50 ‚Üí r√©sultat absurde
- L'utilisateur entre 500 ‚Üí r√©sultat impossible
- L'utilisateur tape des lettres ‚Üí plantage du programme

### Avec validation

```pascal
program AvecValidation;
var
  age: Integer;
begin
  repeat
    Write('√Çge (0-150) : ');
    ReadLn(age);
    if (age < 0) or (age > 150) then
      WriteLn('‚ö†Ô∏è  √Çge invalide. R√©essayez.');
  until (age >= 0) and (age <= 150);

  WriteLn('‚úì Dans 10 ans, vous aurez ', age + 10, ' ans');
  ReadLn;
end.
```

**Avantages :**
- Programme robuste
- Pas de valeurs absurdes
- Meilleure exp√©rience utilisateur

## Types de validation

### 1. Validation de plage (range)

V√©rifier qu'une valeur est dans un intervalle acceptable.

```pascal
program ValidationPlage;
var
  note: Integer;
begin
  WriteLn('Entrez une note (0-20) :');

  repeat
    Write('Note : ');
    ReadLn(note);

    if (note < 0) or (note > 20) then
      WriteLn('‚ùå La note doit √™tre entre 0 et 20');
  until (note >= 0) and (note <= 20);

  WriteLn('‚úì Note enregistr√©e : ', note, '/20');
  ReadLn;
end.
```

### 2. Validation de type

V√©rifier que la donn√©e est du bon type (nombre, lettre, etc.).

```pascal
program ValidationType;
var
  choix: Char;
begin
  WriteLn('Choisissez une option (A/B/C) :');

  repeat
    Write('Choix : ');
    ReadLn(choix);
    choix := UpCase(choix);  // Conversion en majuscule

    if not (choix in ['A', 'B', 'C']) then
      WriteLn('‚ùå Veuillez entrer A, B ou C');
  until choix in ['A', 'B', 'C'];

  WriteLn('‚úì Option ', choix, ' s√©lectionn√©e');
  ReadLn;
end.
```

### 3. Validation de format

V√©rifier que les donn√©es respectent un format sp√©cifique.

```pascal
program ValidationFormat;
var
  codePostal: String;
  i: Integer;
  valide: Boolean;
begin
  WriteLn('Entrez un code postal fran√ßais (5 chiffres) :');

  repeat
    Write('Code postal : ');
    ReadLn(codePostal);

    valide := True;

    // V√©rifier la longueur
    if Length(codePostal) <> 5 then
      valide := False
    else
    begin
      // V√©rifier que tous sont des chiffres
      for i := 1 to 5 do
      begin
        if not (codePostal[i] in ['0'..'9']) then
        begin
          valide := False;
          break;
        end;
      end;
    end;

    if not valide then
      WriteLn('‚ùå Le code postal doit contenir exactement 5 chiffres');
  until valide;

  WriteLn('‚úì Code postal accept√© : ', codePostal);
  ReadLn;
end.
```

### 4. Validation de coh√©rence

V√©rifier que les donn√©es sont logiques entre elles.

```pascal
program ValidationCoherence;
var
  dateNaissance, dateEmbauche: Integer;
begin
  WriteLn('Saisie d''informations employ√© :');

  repeat
    Write('Ann√©e de naissance : ');
    ReadLn(dateNaissance);
    if (dateNaissance < 1900) or (dateNaissance > 2024) then
      WriteLn('‚ùå Ann√©e invalide');
  until (dateNaissance >= 1900) and (dateNaissance <= 2024);

  repeat
    Write('Ann√©e d''embauche : ');
    ReadLn(dateEmbauche);

    if dateEmbauche < dateNaissance then
      WriteLn('‚ùå L''embauche ne peut pas √™tre avant la naissance !')
    else if (dateEmbauche - dateNaissance) < 16 then
      WriteLn('‚ùå L''employ√© doit avoir au moins 16 ans √† l''embauche')
    else if dateEmbauche > 2024 then
      WriteLn('‚ùå Date dans le futur impossible');
  until (dateEmbauche >= dateNaissance + 16) and (dateEmbauche <= 2024);

  WriteLn('‚úì Donn√©es valid√©es');
  ReadLn;
end.
```

## Techniques de validation

### Technique 1 : Validation avec REPEAT-UNTIL

La technique la plus simple et la plus utilis√©e pour les d√©butants.

```pascal
// Structure de base
repeat
  // 1. Demander la saisie
  Write('Valeur : ');
  ReadLn(valeur);

  // 2. V√©rifier et afficher erreur si besoin
  if PasValide(valeur) then
    WriteLn('‚ùå Erreur...');
until EstValide(valeur);
```

**Exemple :**

```pascal
program ValidationRepeat;
var
  pourcentage: Integer;
begin
  repeat
    Write('Pourcentage (0-100) : ');
    ReadLn(pourcentage);

    if (pourcentage < 0) or (pourcentage > 100) then
      WriteLn('‚ùå Doit √™tre entre 0 et 100');
  until (pourcentage >= 0) and (pourcentage <= 100);

  WriteLn('‚úì Pourcentage : ', pourcentage, '%');
  ReadLn;
end.
```

### Technique 2 : Validation avec WHILE et drapeau

Plus flexible, permet de compter les tentatives.

```pascal
program ValidationWhile;
var
  valeur: Integer;
  valide: Boolean;
  tentatives: Integer;
const
  MAX_TENTATIVES = 3;
begin
  valide := False;
  tentatives := 0;

  while (not valide) and (tentatives < MAX_TENTATIVES) do
  begin
    tentatives := tentatives + 1;
    Write('Tentative ', tentatives, '/', MAX_TENTATIVES, ' - Valeur (1-10) : ');
    ReadLn(valeur);

    if (valeur >= 1) and (valeur <= 10) then
    begin
      valide := True;
      WriteLn('‚úì Valeur accept√©e');
    end
    else
      WriteLn('‚ùå Invalide');
  end;

  if not valide then
    WriteLn('Nombre maximum de tentatives atteint');

  ReadLn;
end.
```

### Technique 3 : Fonction de validation

Rendre le code r√©utilisable et plus clair.

```pascal
program ValidationFonction;

function EstNombreEntier(s: String): Boolean;
var
  i: Integer;
begin
  EstNombreEntier := True;

  if Length(s) = 0 then
  begin
    EstNombreEntier := False;
    exit;
  end;

  for i := 1 to Length(s) do
  begin
    if not (s[i] in ['0'..'9']) then
    begin
      EstNombreEntier := False;
      exit;
    end;
  end;
end;

var
  saisie: String;
begin
  repeat
    Write('Entrez un nombre entier : ');
    ReadLn(saisie);

    if not EstNombreEntier(saisie) then
      WriteLn('‚ùå Ce n''est pas un nombre entier valide');
  until EstNombreEntier(saisie);

  WriteLn('‚úì Nombre valide : ', saisie);
  ReadLn;
end.
```

### Technique 4 : Validation avec proc√©dure

Encapsuler toute la logique de validation.

```pascal
program ValidationProcedure;

procedure LireEntierDansIntervalle(message: String; min, max: Integer; var resultat: Integer);
begin
  repeat
    Write(message, ' (', min, '-', max, ') : ');
    ReadLn(resultat);

    if (resultat < min) or (resultat > max) then
      WriteLn('‚ùå Valeur hors limites');
  until (resultat >= min) and (resultat <= max);
end;

var
  age, note: Integer;
begin
  LireEntierDansIntervalle('√Çge', 0, 150, age);
  WriteLn('‚úì √Çge : ', age);

  LireEntierDansIntervalle('Note', 0, 20, note);
  WriteLn('‚úì Note : ', note);

  ReadLn;
end.
```

## Validation de nombres

### Nombres entiers dans un intervalle

```pascal
program ValidationEntierIntervalle;
var
  jour: Integer;
begin
  repeat
    Write('Jour du mois (1-31) : ');
    ReadLn(jour);

    if (jour < 1) or (jour > 31) then
    begin
      WriteLn('‚ùå Jour invalide');
      WriteLn('   Les jours vont de 1 √† 31');
    end;
  until (jour >= 1) and (jour <= 31);

  WriteLn('‚úì Jour : ', jour);
  ReadLn;
end.
```

### Nombres d√©cimaux positifs

```pascal
program ValidationDecimalPositif;
var
  prix: Real;
begin
  repeat
    Write('Prix en euros : ');
    ReadLn(prix);

    if prix < 0 then
      WriteLn('‚ùå Le prix ne peut pas √™tre n√©gatif')
    else if prix > 1000000 then
      WriteLn('‚ùå Prix trop √©lev√© (max 1 000 000 ‚Ç¨)');
  until (prix >= 0) and (prix <= 1000000);

  WriteLn('‚úì Prix : ', prix:0:2, ' ‚Ç¨');
  ReadLn;
end.
```

### Nombres avec pr√©cision

```pascal
program ValidationPrecision;
var
  note: Real;
  valide: Boolean;
begin
  repeat
    Write('Note (0.0 √† 20.0, max 1 d√©cimale) : ');
    ReadLn(note);

    valide := True;

    if (note < 0) or (note > 20) then
    begin
      WriteLn('‚ùå Note hors limites');
      valide := False;
    end
    else if (note * 10) <> Trunc(note * 10) then
    begin
      WriteLn('‚ùå Maximum 1 d√©cimale (ex: 15.5)');
      valide := False;
    end;
  until valide;

  WriteLn('‚úì Note : ', note:0:1, '/20');
  ReadLn;
end.
```

## Validation de caract√®res et cha√Ænes

### Validation d'un seul caract√®re

```pascal
program ValidationCaractere;
var
  reponse: Char;
begin
  repeat
    Write('Continuer ? (O/N) : ');
    ReadLn(reponse);
    reponse := UpCase(reponse);

    if not (reponse in ['O', 'N']) then
      WriteLn('‚ùå R√©pondez par O (Oui) ou N (Non)');
  until reponse in ['O', 'N'];

  if reponse = 'O' then
    WriteLn('‚úì Continuation...')
  else
    WriteLn('‚úì Arr√™t');

  ReadLn;
end.
```

### Validation de cha√Æne non vide

```pascal
program ValidationNonVide;
var
  nom: String;
begin
  repeat
    Write('Nom : ');
    ReadLn(nom);

    // Supprimer les espaces au d√©but et √† la fin
    nom := Trim(nom);

    if Length(nom) = 0 then
      WriteLn('‚ùå Le nom ne peut pas √™tre vide');
  until Length(nom) > 0;

  WriteLn('‚úì Bonjour ', nom, ' !');
  ReadLn;
end.
```

### Validation de longueur

```pascal
program ValidationLongueur;
var
  motDePasse: String;
const
  LONGUEUR_MIN = 8;
  LONGUEUR_MAX = 20;
begin
  repeat
    Write('Mot de passe (', LONGUEUR_MIN, '-', LONGUEUR_MAX, ' caract√®res) : ');
    ReadLn(motDePasse);

    if Length(motDePasse) < LONGUEUR_MIN then
      WriteLn('‚ùå Trop court (min ', LONGUEUR_MIN, ' caract√®res)')
    else if Length(motDePasse) > LONGUEUR_MAX then
      WriteLn('‚ùå Trop long (max ', LONGUEUR_MAX, ' caract√®res)');
  until (Length(motDePasse) >= LONGUEUR_MIN) and
        (Length(motDePasse) <= LONGUEUR_MAX);

  WriteLn('‚úì Mot de passe accept√©');
  ReadLn;
end.
```

### Validation de format de cha√Æne

```pascal
program ValidationEmail;
var
  email: String;
  posArobase, posPoint: Integer;
  valide: Boolean;
begin
  repeat
    Write('Email : ');
    ReadLn(email);

    valide := True;
    posArobase := Pos('@', email);

    // V√©rifications basiques
    if Length(email) < 5 then
    begin
      WriteLn('‚ùå Email trop court');
      valide := False;
    end
    else if posArobase = 0 then
    begin
      WriteLn('‚ùå L''email doit contenir @');
      valide := False;
    end
    else if posArobase = 1 then
    begin
      WriteLn('‚ùå L''email ne peut pas commencer par @');
      valide := False;
    end
    else
    begin
      // V√©rifier qu'il y a un point apr√®s le @
      posPoint := Pos('.', Copy(email, posArobase, Length(email)));
      if posPoint = 0 then
      begin
        WriteLn('‚ùå L''email doit avoir un point apr√®s @');
        valide := False;
      end;
    end;
  until valide;

  WriteLn('‚úì Email accept√© : ', email);
  ReadLn;
end.
```

## Validation de choix multiples

### Menu avec validation

```pascal
program MenuAvecValidation;
var
  choix: Integer;
begin
  WriteLn('‚ïê‚ïê‚ïê MENU PRINCIPAL ‚ïê‚ïê‚ïê');
  WriteLn('1. Nouveau');
  WriteLn('2. Ouvrir');
  WriteLn('3. Enregistrer');
  WriteLn('4. Quitter');
  WriteLn;

  repeat
    Write('Votre choix (1-4) : ');
    ReadLn(choix);

    if (choix < 1) or (choix > 4) then
      WriteLn('‚ùå Veuillez choisir entre 1 et 4');
  until (choix >= 1) and (choix <= 4);

  WriteLn('‚úì Option ', choix, ' s√©lectionn√©e');
  ReadLn;
end.
```

### Choix parmi des options textuelles

```pascal
program ChoixTextuels;
var
  couleur: String;
  valide: Boolean;
begin
  WriteLn('Couleurs disponibles : rouge, vert, bleu');

  repeat
    Write('Votre couleur : ');
    ReadLn(couleur);
    couleur := LowerCase(couleur);

    valide := (couleur = 'rouge') or (couleur = 'vert') or (couleur = 'bleu');

    if not valide then
      WriteLn('‚ùå Couleur non disponible');
  until valide;

  WriteLn('‚úì Couleur choisie : ', couleur);
  ReadLn;
end.
```

## Validation combin√©e

### Plusieurs crit√®res simultan√©s

```pascal
program ValidationCombinee;
var
  code: String;
  i: Integer;
  nbChiffres, nbLettres: Integer;
  valide: Boolean;
const
  LONGUEUR_CODE = 6;
begin
  WriteLn('Cr√©ez un code de ', LONGUEUR_CODE, ' caract√®res');
  WriteLn('(doit contenir au moins 1 chiffre et 1 lettre)');
  WriteLn;

  repeat
    Write('Code : ');
    ReadLn(code);

    valide := True;
    nbChiffres := 0;
    nbLettres := 0;

    // V√©rifier la longueur
    if Length(code) <> LONGUEUR_CODE then
    begin
      WriteLn('‚ùå Le code doit faire exactement ', LONGUEUR_CODE, ' caract√®res');
      valide := False;
    end
    else
    begin
      // Compter chiffres et lettres
      for i := 1 to Length(code) do
      begin
        if code[i] in ['0'..'9'] then
          nbChiffres := nbChiffres + 1
        else if code[i] in ['A'..'Z', 'a'..'z'] then
          nbLettres := nbLettres + 1;
      end;

      if nbChiffres = 0 then
      begin
        WriteLn('‚ùå Le code doit contenir au moins 1 chiffre');
        valide := False;
      end;

      if nbLettres = 0 then
      begin
        WriteLn('‚ùå Le code doit contenir au moins 1 lettre');
        valide := False;
      end;

      if (nbChiffres + nbLettres) <> LONGUEUR_CODE then
      begin
        WriteLn('‚ùå Le code ne doit contenir que des chiffres et des lettres');
        valide := False;
      end;
    end;
  until valide;

  WriteLn('‚úì Code valide : ', code);
  ReadLn;
end.
```

### Validation de date

```pascal
program ValidationDate;
var
  jour, mois, annee: Integer;
  joursMax: Integer;
  valide: Boolean;
begin
  WriteLn('Entrez une date :');

  // Validation du jour
  repeat
    Write('Jour (1-31) : ');
    ReadLn(jour);
  until (jour >= 1) and (jour <= 31);

  // Validation du mois
  repeat
    Write('Mois (1-12) : ');
    ReadLn(mois);
  until (mois >= 1) and (mois <= 12);

  // Validation de l'ann√©e
  repeat
    Write('Ann√©e (1900-2100) : ');
    ReadLn(annee);
  until (annee >= 1900) and (annee <= 2100);

  // Validation de coh√©rence jour/mois
  valide := True;

  case mois of
    1, 3, 5, 7, 8, 10, 12: joursMax := 31;
    4, 6, 9, 11: joursMax := 30;
    2:  // F√©vrier
      begin
        // Ann√©e bissextile (simplifi√©e)
        if (annee mod 4 = 0) and ((annee mod 100 <> 0) or (annee mod 400 = 0)) then
          joursMax := 29
        else
          joursMax := 28;
      end;
  else
    joursMax := 31;
  end;

  if jour > joursMax then
  begin
    WriteLn('‚ùå ERREUR : Ce mois n''a que ', joursMax, ' jours');
    valide := False;
  end;

  if valide then
  begin
    WriteLn('‚úì Date valide : ', jour, '/', mois, '/', annee);
    if (mois = 2) and (joursMax = 29) then
      WriteLn('  (', annee, ' est une ann√©e bissextile)');
  end;

  ReadLn;
end.
```

## Exemples pratiques complets

### Formulaire d'inscription

```pascal
program FormulaireInscription;
var
  nom, prenom, email, telephone: String;
  age: Integer;
  i, posArobase: Integer;
  valide: Boolean;
begin
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn('   FORMULAIRE D''INSCRIPTION');
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn;

  // Nom
  repeat
    Write('Nom : ');
    ReadLn(nom);
    nom := Trim(nom);

    if Length(nom) < 2 then
      WriteLn('‚ùå Le nom doit contenir au moins 2 caract√®res');
  until Length(nom) >= 2;

  // Pr√©nom
  repeat
    Write('Pr√©nom : ');
    ReadLn(prenom);
    prenom := Trim(prenom);

    if Length(prenom) < 2 then
      WriteLn('‚ùå Le pr√©nom doit contenir au moins 2 caract√®res');
  until Length(prenom) >= 2;

  // √Çge
  repeat
    Write('√Çge : ');
    ReadLn(age);

    if (age < 18) or (age > 100) then
      WriteLn('‚ùå Vous devez avoir entre 18 et 100 ans');
  until (age >= 18) and (age <= 100);

  // Email
  repeat
    Write('Email : ');
    ReadLn(email);
    email := Trim(email);
    valide := True;

    posArobase := Pos('@', email);
    if (posArobase = 0) or (posArobase = 1) or (posArobase = Length(email)) then
    begin
      WriteLn('‚ùå Format d''email invalide');
      valide := False;
    end;
  until valide;

  // T√©l√©phone
  repeat
    Write('T√©l√©phone (10 chiffres) : ');
    ReadLn(telephone);
    valide := True;

    if Length(telephone) <> 10 then
    begin
      WriteLn('‚ùå Le num√©ro doit contenir 10 chiffres');
      valide := False;
    end
    else
    begin
      for i := 1 to 10 do
      begin
        if not (telephone[i] in ['0'..'9']) then
        begin
          WriteLn('‚ùå Le num√©ro ne doit contenir que des chiffres');
          valide := False;
          break;
        end;
      end;
    end;
  until valide;

  // R√©capitulatif
  WriteLn;
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn('   R√âCAPITULATIF');
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn('Nom : ', nom);
  WriteLn('Pr√©nom : ', prenom);
  WriteLn('√Çge : ', age, ' ans');
  WriteLn('Email : ', email);
  WriteLn('T√©l√©phone : ', telephone);
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn('‚úì Inscription valid√©e !');

  ReadLn;
end.
```

### Syst√®me de paiement

```pascal
program SystemePaiement;
var
  montant, montantPaye, rendu: Real;
  valide: Boolean;
begin
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn('   SYST√àME DE PAIEMENT');
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn;

  // Montant de l'achat
  repeat
    Write('Montant de l''achat : ');
    ReadLn(montant);

    if montant <= 0 then
      WriteLn('‚ùå Le montant doit √™tre positif')
    else if montant > 10000 then
      WriteLn('‚ùå Montant trop √©lev√© (max 10 000 ‚Ç¨)');
  until (montant > 0) and (montant <= 10000);

  WriteLn;
  WriteLn('Montant √† payer : ', montant:0:2, ' ‚Ç¨');
  WriteLn;

  // Montant pay√©
  repeat
    Write('Montant pay√© : ');
    ReadLn(montantPaye);
    valide := True;

    if montantPaye < 0 then
    begin
      WriteLn('‚ùå Le montant ne peut pas √™tre n√©gatif');
      valide := False;
    end
    else if montantPaye < montant then
    begin
      WriteLn('‚ùå Montant insuffisant');
      WriteLn('   Il manque ', (montant - montantPaye):0:2, ' ‚Ç¨');
      valide := False;
    end;
  until valide;

  // Calcul du rendu
  rendu := montantPaye - montant;

  WriteLn;
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn('Montant pay√© : ', montantPaye:0:2, ' ‚Ç¨');
  if rendu > 0 then
    WriteLn('Rendu : ', rendu:0:2, ' ‚Ç¨')
  else
    WriteLn('Paiement exact');
  WriteLn('‚úì Transaction termin√©e');
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

  ReadLn;
end.
```

### Configuration de profil utilisateur

```pascal
program ConfigurationProfil;
var
  pseudo: String;
  avatar: Integer;
  notifications: Char;
  i: Integer;
  valide: Boolean;
begin
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn('   CONFIGURATION DU PROFIL');
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn;

  // Pseudo
  repeat
    Write('Pseudo (3-15 caract√®res, lettres et chiffres uniquement) : ');
    ReadLn(pseudo);
    valide := True;

    if (Length(pseudo) < 3) or (Length(pseudo) > 15) then
    begin
      WriteLn('‚ùå Le pseudo doit contenir entre 3 et 15 caract√®res');
      valide := False;
    end
    else
    begin
      for i := 1 to Length(pseudo) do
      begin
        if not (pseudo[i] in ['A'..'Z', 'a'..'z', '0'..'9']) then
        begin
          WriteLn('‚ùå Le pseudo ne doit contenir que des lettres et chiffres');
          valide := False;
          break;
        end;
      end;
    end;
  until valide;

  // Choix d'avatar
  WriteLn;
  WriteLn('Avatars disponibles :');
  WriteLn('1. üòä Souriant');
  WriteLn('2. üòé Cool');
  WriteLn('3. ü§ì Geek');
  WriteLn('4. üê± Chat');
  WriteLn('5. ü¶ä Renard');
  WriteLn;

  repeat
    Write('Choisissez votre avatar (1-5) : ');
    ReadLn(avatar);

    if (avatar < 1) or (avatar > 5) then
      WriteLn('‚ùå Veuillez choisir entre 1 et 5');
  until (avatar >= 1) and (avatar <= 5);

  // Notifications
  WriteLn;
  repeat
    Write('Activer les notifications ? (O/N) : ');
    ReadLn(notifications);
    notifications := UpCase(notifications);

    if not (notifications in ['O', 'N']) then
      WriteLn('‚ùå R√©pondez par O (Oui) ou N (Non)');
  until notifications in ['O', 'N'];

  // R√©capitulatif
  WriteLn;
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn('   PROFIL CONFIGUR√â');
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn('Pseudo : ', pseudo);
  Write('Avatar : ');
  case avatar of
    1: WriteLn('üòä Souriant');
    2: WriteLn('üòé Cool');
    3: WriteLn('ü§ì Geek');
    4: WriteLn('üê± Chat');
    5: WriteLn('ü¶ä Renard');
  end;
  Write('Notifications : ');
  if notifications = 'O' then
    WriteLn('Activ√©es')
  else
    WriteLn('D√©sactiv√©es');
  WriteLn('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  WriteLn('‚úì Configuration enregistr√©e !');

  ReadLn;
end.
```

## Feedback utilisateur

### Messages progressifs

```pascal
// ‚ùå Pas de feedback
repeat
  ReadLn(valeur);
until (valeur >= 1) and (valeur <= 100);

// ‚úì Avec feedback
repeat
  Write('Valeur (1-100) : ');
  ReadLn(valeur);

  if valeur < 1 then
    WriteLn('‚ùå Trop petit (minimum : 1)')
  else if valeur > 100 then
    WriteLn('‚ùå Trop grand (maximum : 100)')
  else
    WriteLn('‚úì Valeur accept√©e');
until (valeur >= 1) and (valeur <= 100);
```

### Compteur de tentatives

```pascal
program CompteurTentatives;
var
  code: Integer;
  tentative: Integer;
const
  CODE_SECRET = 1234;
  MAX_TENTATIVES = 3;
begin
  WriteLn('Entrez le code secret :');

  tentative := 0;
  repeat
    tentative := tentative + 1;
    Write('Tentative ', tentative, '/', MAX_TENTATIVES, ' : ');
    ReadLn(code);

    if code <> CODE_SECRET then
    begin
      WriteLn('‚ùå Code incorrect');
      if tentative < MAX_TENTATIVES then
        WriteLn('   Il vous reste ', MAX_TENTATIVES - tentative, ' tentative(s)');
    end;
  until (code = CODE_SECRET) or (tentative >= MAX_TENTATIVES);

  if code = CODE_SECRET then
    WriteLn('‚úì Acc√®s autoris√©')
  else
    WriteLn('‚úó Acc√®s refus√© - Trop de tentatives');

  ReadLn;
end.
```

## Erreurs courantes

### 1. Validation trop stricte

```pascal
// ‚ùå Trop strict
if nom <> 'Dupont' then
  WriteLn('Erreur');

// ‚úì Validation raisonnable
if Length(nom) < 2 then
  WriteLn('Nom trop court');
```

### 2. Oublier de trim les espaces

```pascal
// ‚ùå Les espaces comptent
if nom = '' then
  WriteLn('Vide');

// ‚úì Suppression des espaces
nom := Trim(nom);
if nom = '' then
  WriteLn('Vide');
```

### 3. Validation apr√®s utilisation

```pascal
// ‚ùå Utilise avant de valider
resultat := a / b;
if b = 0 then
  WriteLn('Erreur');

// ‚úì Valide avant d'utiliser
if b = 0 then
  WriteLn('Erreur')
else
  resultat := a / b;
```

### 4. Messages d'erreur inutiles

```pascal
// ‚ùå Message inutile
if valeur < 0 then
  WriteLn('Erreur');

// ‚úì Message explicatif
if valeur < 0 then
  WriteLn('‚ùå La valeur doit √™tre positive (vous avez entr√© ', valeur, ')');
```

### 5. Pas de feedback positif

```pascal
// ‚ùå Rien quand c'est bon
repeat
  ReadLn(valeur);
  if valeur < 0 then
    WriteLn('Invalide');
until valeur >= 0;

// ‚úì Confirmation
repeat
  ReadLn(valeur);
  if valeur < 0 then
    WriteLn('‚ùå Invalide')
  else
    WriteLn('‚úì Valeur accept√©e');
until valeur >= 0;
```

## Bonnes pratiques

### 1. Utiliser des constantes

```pascal
const
  AGE_MIN = 0;
  AGE_MAX = 150;
begin
  if (age < AGE_MIN) or (age > AGE_MAX) then
    WriteLn('√Çge invalide : ', AGE_MIN, '-', AGE_MAX);
end;
```

### 2. Extraire en fonctions

```pascal
function EstEmailValide(email: String): Boolean;
begin
  // Logique de validation
  EstEmailValide := (Pos('@', email) > 0);
end;
```

### 3. Messages clairs et constructifs

```pascal
WriteLn('‚ùå Mot de passe invalide');
WriteLn('   ‚Ä¢ Minimum 8 caract√®res');
WriteLn('   ‚Ä¢ Au moins 1 chiffre');
WriteLn('   ‚Ä¢ Au moins 1 lettre');
```

### 4. Donner des exemples

```pascal
WriteLn('Format : JJ/MM/AAAA');
WriteLn('Exemple : 25/12/2024');
```

### 5. Confirmer les saisies valides

```pascal
WriteLn('‚úì Email accept√© : ', email);
WriteLn('‚úì T√©l√©phone accept√© : ', telephone);
```

## R√©sum√©

La validation des entr√©es utilisateur est essentielle pour cr√©er des programmes robustes :

### Types de validation
- **Plage** : v√©rifier les limites min/max
- **Type** : s'assurer du bon type de donn√©es
- **Format** : respecter une structure sp√©cifique
- **Coh√©rence** : logique entre plusieurs donn√©es

### Techniques
- **REPEAT-UNTIL** : la plus simple et courante
- **WHILE** : plus flexible, permet de compter
- **Fonctions** : code r√©utilisable
- **Proc√©dures** : encapsulation compl√®te

### Principes cl√©s
- Ne **jamais** faire confiance aux entr√©es
- Valider **avant** d'utiliser les donn√©es
- Donner des **messages clairs**
- Offrir la **possibilit√© de r√©essayer**
- **Confirmer** les saisies valides

### Messages efficaces
- ‚ùå Indiquer l'erreur
- ‚ÑπÔ∏è Expliquer pourquoi
- ‚úì Confirmer quand c'est bon
- üí° Donner des exemples

La validation est la premi√®re ligne de d√©fense contre les erreurs. Un programme bien valid√© = un programme robuste et professionnel !

‚è≠Ô∏è [D√©bogage pas √† pas](/03-structures-controle/09-debogage-pas-a-pas.md)
